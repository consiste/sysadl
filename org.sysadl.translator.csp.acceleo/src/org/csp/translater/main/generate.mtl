[comment encoding = UTF-8 /]
[module generate('http://org.sysadl')]
[import org::csp::translater::query::auxQuery /]

[template public generateModel(aModel : sysadl::Model)]
[comment @main/]

[if (ExistEqualsNames(aModel).toString().startsWith('Sucess') = false and CheckPortsAndPinsNames(aModel).toString().startsWith('Sucess'))]
[file ('sysadl2csp.csp', false, 'UTF-8')]
subset(s1, s2) = (inter(s1,s2)==s1)

MAX = 4

SysADLChar = {'a','b','c'}

FSeq(T,0) = {<>}
FSeq(T,1) = union( FSeq(T,0), {<z> | z <- T} )
FSeq(T,s) = {z^z'| z <- FSeq(T,1), z' <- FSeq(T,s-1)}

String = FSeq(SysADLChar,MAX)

	[for (pck : sysadl::Package | aModel.packages)]		
	[comment Types /]		
		[for (elem : ElementDef | pck.definitions)]
			[let unity : UnitDef = self]				
				[for (type : ElementDef | pck.definitions)? (type.oclIsKindOf(TypeDef))]
					[if (unity.name + '' + unity.dimension.name = type.name)]
[type.name/] = [getTypeUnity(type.oclAsType(TypeDef))/]						
					[/if]
				[/for]		
			[/let]			
			[let aux : Enumeration = self]
datatype [aux.name/] = [for (literal : EnumLiteralValue | aux.literals)separator ('|')][literal.name/][/for] 					
			[/let]		
			[let datatype : DataTypeDef = self]
[datatype.name/] = { [for (attribute : TypeUse | datatype.attributes)before ('(')separator(',')after (')')][attribute.name/][/for] | [for (attributeDef : TypeUse | datatype.attributes) separator (',')][attributeDef.name/]<- [if (attributeDef.definition.name = 'String')]String [elseif(attributeDef.definition.name = 'Boolean')]Bool[elseif(attributeDef.definition.name = 'Int')]{0 .. 5}[elseif(attributeDef.definition.name = 'Real')]Nat.Nat[else][attributeDef.definition.name/][/if] [/for] }
[for (attribute : TypeUse | datatype.attributes)separator ('\n')][datatype.name/]_[attribute.name/]([for (attribute : TypeUse | datatype.attributes)before ('(')separator(',')after (')')][attribute.name/][/for]) = [attribute.name/][/for]
			[/let]
		[/for]
	[/for]

	[comment channel/]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]			
			[let channel : ComponentDef = self]				
				[for (port : PortUse | channel.ports)]
					[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[port.definition.name/] : [getTypePort(port)/]						
					[elseif (port.definition.oclIsKindOf(sysadl::CompositePortDef))]
					[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports )]
						[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[compPort.name/]_[port.definition.name/] : [getTypePort(compPort)/]
						[/if]
					[/for]
					[/if]
				[/for]				
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let connector : ConnectorDef = self]
				[for (port : PortUse | connector.ports)]
					[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[port.definition.name/] : [getTypePort(port)/]						
					[elseif (port.definition.oclIsKindOf(sysadl::CompositePortDef))]
					[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports )]
						[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[compPort.name/]_[port.definition.name/] : [getTypePort(compPort)/]
						[/if]
					[/for]
					[/if]
				[/for]
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = elem]					
				[if ( compDef.isBoundary = false and compDef.composite <> null)]		
					[for (compUse : ComponentUse| compDef.composite.components)]
						[for (portUse : PortUse | compUse.ports)]
							[if (portUse.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [compUse.name/]_[portUse.name/]_[portUse.definition.name/] : [getTypePort(portUse)/]
							[/if]
							[if (portUse.definition.oclIsKindOf(sysadl::CompositePortDef))]
							[for (compPort : PortUse | portUse.definition.oclAsType(sysadl::CompositePortDef).ports )]
								[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [compUse.name/]_[portUse.name/]_[compPort.name/]_[portUse.definition.name/] : [getTypePort(compPort)/]
								[/if]
							[/for]
							[/if]
						[/for]
					[/for]
				[/if]			
			[/let]
		[/for]
	[/for]


	[comment configuration/]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]
				[if (compDef.composite <> null)]
					[if (isEmpty_Delegations(compDef.composite))]
[compDef.name/] = 
['\t'/][compDef.name/]_config

[compDef.name/]_config = (Components_[compDef.name/] ['['/]| Sync_[compDef.name/] |] Connectors_[compDef.name/])\Internal_[compDef.name/]

Sync_[compDef.name/] = {| [for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')? (compUse.definition.composite = null)][for (portUse : PortUse | compUse.ports)separator (',')][compUse.name/]_[portUse.name/]_[portUse.definition.name/][/for][/for],
					[for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')? (compUse.definition.isBoundary = false)][for (port : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')][compUse.name/]_[port.name/]_[port.definition.name/][/for][/for] |}

Internal_[compDef.name/] = {| [for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')? (compUse.definition.isBoundary = false)][for (port : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')][compUse.name/]_[port.name/]_[port.definition.name/][/for][/for]|}

Components_[compDef.name/] = [getSequenceFromComponentConfigWithRename(compDef)/];Components_[compDef.name/]

Connectors_[compDef.name/] = ([for (conn : ConnectorUse | compDef.composite.connectors)separator ('\n\t\t\t\t\t\t|||')][conn.definition.name/]['[['/][getRenamePortsConnector(conn, compDef)/]]][/for]);Connectors_[compDef.name/]
													
					[/if]					
				[/if]				
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]					
				[if ((compDef.composite <> null and isEmpty_Delegations(compDef.composite) = false))]					
[compDef.name/]_config = (Components_[compDef.name/] ['['/]| Sync_[compDef.name/] |]  Connectors_[compDef.name/])\Internal_[compDef.name/]

Sync_[compDef.name/] = Internal_[compDef.name/]

Internal_[compDef.name/] = {| [for (comp : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t\t')][for (port : PortUse | comp.ports)separator (',\n\t\t\t\t\t\t')][comp.name/]_[port.name/]_[port.definition.name/][/for][/for] |}

Components_[compDef.name/] = [getSequenceFromComponentConfigWithRename(compDef)/]

Connectors_[compDef.name/] = [for (conn : ConnectorUse | compDef.composite.connectors)separator ('\n\t\t\t\t\t\t|||')][conn.definition.name/]['[['/][getRenamePortsConnector(conn, compDef)/]]][/for]			
															
				[/if]							
			[/let]			
		[/for]
	[/for]

	[comment components/]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]
				[if (((compDef.composite <> null) and isEmpty_Delegations(compDef.composite) = false))]										
[compDef.name/] =
	[compDef.name/]_config																	
				[/if]				
				[if (compDef.composite = null and compDef.isBoundary = true)]												
[compDef.name/] = 
					[for (port : PortUse | compDef.ports)]								
						[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
							[if (port.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('in'))]
	['\t'/][port.name/]_[port.definition.name/]?[port.name/] ->
							[/if]
						[else]
							[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports)]
								[if (compPort.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('in'))]
	['\t'/][port.name/]_[compPort.name/]_[port.definition.name/]?[compPort.name/] ->
								[/if]
							[/for]
						[/if]
					[/for]
					[for (port : PortUse | compDef.ports)]								
						[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
							[if (port.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('out'))]
['\t'/]|~| [port.name/]:[getTypePort(port)/] @ [port.name/]_[port.definition.name/]![port.name/] ->
							[/if]
						[else]
							[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports)]
								[if (compPort.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('out'))]
['\t'/]|~|[compPort.name/]:[getTypePort(port)/] @ [port.name/]_[compPort.name/]_[port.definition.name/]![compPort.name/] ->
								[/if]
							[/for]
						[/if]
					[/for]
	SKIP
								
				[elseif(compDef.composite = null and compDef.isBoundary = false)]
[compDef.name/] =								
['\t'/][getActivityToStructure(compDef, aModel.allocation)/]				
				[/if]
			[/let]
		[/for]
	[/for]
[comment connector/]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let connDef : ConnectorDef = self]
[connDef.name/] = 
				[if (connDef.getActivityToStructure(connDef, aModel.allocation) = '' and connDef.composite = null)]											
					[for (port : PortUse | connDef.ports)]
						[if (port.definition.oclIsTypeOf(SimplePortDef))]
							[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))]
		[port.name/]_[port.definition.oclAsType(SimplePortDef).name/]?out ->
							[/if]
						[/if]						
					[/for]
					[for (port : PortUse | connDef.ports)]
						[if (port.definition.oclIsKindOf(SimplePortDef))]
							[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))]
		[port.name/]_[port.definition.oclAsType(SimplePortDef).name/]!out ->
							[/if]
						[/if]
					[/for]
SKIP
				[elseif (connDef.composite <> null)]
					[for (conn : ConnectorUse | connDef.composite.connectors)separator ('\n\t\t\t\t\t\t|||')][conn.definition.name/]['[['/][getRenamePortsConnector(conn, connDef)/]]][/for]
					

				[else]
		[connDef.getActivityToStructure(connDef, aModel.allocation)/]

				[/if]
			[/let]
		[/for]
	[/for]


	[comment activities /]	
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let activity : ActivityDef = self]
				[if (not activity.name.toString().startsWith('SPEC'))]					
				[for (flow : ActivityRelation | activity._body.flows)]
					[if (flow.target.oclIsKindOf(Pin) and flow.oclIsKindOf(ActivityFlow))]
channel [flow.target.oclAsType(Pin).name/]_[flow.target.oclAsType(Pin).definition.name/] : [getTypePin(flow.target.oclAsType(Pin))/]	
					[else]
channel [flow.source.oclAsType(Pin).name/]_[flow.source.oclAsType(Pin).definition.name/] : [getTypePin(flow.source.oclAsType(Pin))/]
					[/if]
				[/for]	 
[for (flow : ActivityRelation | activity._body.flows)separator ('\n')? (flow.source.oclIsTypeOf(ActionUse) and flow.target.oclIsTypeOf(Pin))]channel  [flow.source.oclAsType(ActionUse).name/]_[flow.target.oclAsType(Pin).name/] : [flow.source.oclAsType(ActionUse).definition.returnType.name/][/for]

[activity.name/] = Actions_[activity.name/] ['[['/] 
	[for (alloc : Allocation | aModel.allocation.allocs)]
		[if (alloc.oclIsTypeOf(ActivityAllocation) and  alloc.oclAsType(ActivityAllocation).source.name.toString().equalsIgnoreCase(activity.name.toString()))]
			[for (pin : Pin | alloc.oclAsType(ActivityAllocation).source.inParameters)separator (',')after (',')]
				[pin.name/]_[pin.definition.name/] <- 
				[if (alloc.oclAsType(ActivityAllocation).target.oclIsTypeOf(ConnectorDef))]
					[for (portIn : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ConnectorDef).ports)]						
						[if (portIn.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))]
				[portIn.name/]_[portIn.definition.name/]
						[/if]
					[/for]											
				[elseif (alloc.oclAsType(ActivityAllocation).target.oclIsTypeOf(ComponentDef))]
					[for (portIn : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ComponentDef).ports)]						
						[if (portIn.name.toString().equalsIgnoreCase(pin.name.toString()))]
				[portIn.name/]_[portIn.definition.name/]
						[/if]
					[/for]								
				[/if]				
			[/for]
			[for (pin : Pin | alloc.oclAsType(ActivityAllocation).source.outParameters)separator (',')]
				[pin.name/]_[pin.definition.name/] <- 
				[if (alloc.oclAsType(ActivityAllocation).target.oclIsTypeOf(ConnectorDef))]
					[for (portIn : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ConnectorDef).ports)]						
						[if (portIn.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))]
				[portIn.name/]_[portIn.definition.name/]
						[/if]
					[/for]								
				[elseif (alloc.oclAsType(ActivityAllocation).target.oclIsTypeOf(ComponentDef))]
					[for (portIn : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ComponentDef).ports)]						
						[if (portIn.name.toString().equalsIgnoreCase(pin.name.toString()))]
				[portIn.name/]_[portIn.definition.name/]
						[/if]
					[/for]
				[/if][/for][/if][/for]]]

Actions_[activity.name/] = [getActionFuncProcess(activity)/]
 		 
				[for (action : ActionUse | activity._body.actions)]
[action.name/]_[action.definition.name/] = 
['\t'/][getActionBody(activity,action)/]
SKIP

				[/for]
				[/if]
			[/let]
		[/for]
	[/for]

[comment Constraint /]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let constraint : ConstraintDef = self]
				[if (not constraint.name.toString().startsWith('SPEC'))]					
[constraint.name/]([if (constraint.inParameters <> null)]x[/if][for (param : Pin | constraint.inParameters)before (',')separator (',')][param.name/][/for]) = [constraint.getContraints(constraint)/]

[constraint.name/]_check = 
			{([for (paramIn : Pin | constraint.inParameters)separator (', ')]
[paramIn.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/] <- [getTypePin(paramIn)/] [/for], 
						not ({[for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for] | [for (out : Pin | constraint.outParameters)separator (',')][out.name/] <- [getTypePin(out)/][/for],
							[constraint.name/]([for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for],[for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for])} == {})}
			==
			{([for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/] <- [getTypePin(paramIn)/][/for]}

print [constraint.name/]_check

[constraint.name/]_case_false = 
			{([for (paramIn : Pin | constraint.inParameters)separator (', ')]
[paramIn.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/] <- [getTypePin(paramIn)/] [/for], 
						 ({[for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for] | [for (out : Pin | constraint.outParameters)separator (',')][out.name/] <- [getTypePin(out)/][/for],
							[constraint.name/]([for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for],[for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for])} == {})}

[constraint.name/]_s = 
			{([for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for],[for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/] <- [getTypePin(paramIn)/][/for],
['\t\t\t'/][for (out : Pin | constraint.outParameters)separator (',')][out.name/] <- [getTypePin(out)/][/for],
['\t\t\t'/][constraint.name/]([for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for],[for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for])}  
			[/if]			
		[/let]

[comment Protocols /]
			[let protocol : Protocol = self]
				[for (pin : Pin | protocol.inParameters)]
channel [pin.name/]_[pin.definition.name/]:[pin.definition.name/]
				[/for]
				[for (pin : Pin | protocol.outParameters)]
channel [pin.name/]_[pin.definition.name/]:[pin.definition.name/]
				[/for]
[protocol.name/] = 
				[for (pin : Pin | protocol.inParameters)]
	[pin.name/]_[pin.definition.name/]?var ->
				[/for]
				[for (pin : Pin | protocol.outParameters)]
	[pin.name/]_[pin.definition.name/]!var ->
				[/for]
	[protocol.name/]
			[/let]

[comment execution /]
			[let exe: Executable = self]
[exe.name/]([for (param : TypeUse | exe.params)separator (',')][param.name/][/for])= [exe.getExecution(exe)/]

[exe.name/]_s = 
			{([for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/][/for],[for (out : TypeDef | exe.returnType)separator (',')][out.name/][/for]) | [for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/] <- [getTypeCSP(paramIn.definition)/][/for],
['\t\t\t'/][for (out : TypeDef | exe.returnType)separator (',')][out.name/] <- [getTypeCSP(out)/][/for],
['\t\t\t'/][exe.returnType.name/] == [exe.name/]([for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/][/for])}

			[/let]
		[/for]
	[/for]
channel ERROR
[for (pck : Package | aModel.packages)]
	[for (elem : ElementDef | pck.definitions)]
		[let compDef : ComponentDef = elem]					
			[if (compDef.composite <> null and isEmpty_Delegations(compDef.composite))]
[compDef.name/]_ALF = {|[for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')after ('|}')][for (portUse : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')][compUse.name/]_[portUse.name/]_[portUse.definition.name/][/for][/for]
			[/if]		
		[/let]
		[let spec : ActionDef = self]
			[if (spec.name.toString().startsWith('SPEC_'))]
				[if (existPinOfPortOPT(spec, aModel) =  1 )]
[spec.name/] =	[spec.name/]_PRE([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/], false[/for])
[spec.name/]_PRE([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [pin.name/], [pin.name/]_bool[/for]) = 
				[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_PRE([for (pin1 : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
([for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for])[spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])					
				
				[elseif (existPinOfPortOPT(spec, aModel) =  0)]

[spec.name/] =	[spec.name/]_POS([for (pin : Pin | spec.inParameters)? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/],false[/for])			
[spec.name/]_POS([for (pin : Pin | spec.inParameters)? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [pin.name/],[pin.name/]_bool[/for]) =
	[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (not isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_POS([for (pin1 : Pin | spec.inParameters)? (isPinFromPortIn(pin1, aModel))] [pin1.name/][/for][for (pin1 : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (not isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])

				[elseif (existPinOfPortOPT(spec, aModel) =  2)]

[spec.name/] =	[spec.name/]_PRE([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/], false[/for])

[spec.name/]_PRE([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [pin.name/], [pin.name/]_bool[/for]) = 
				[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_PRE([for (pin1 : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_POS([for (pin : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/],false[/for]) 
			
[spec.name/]_POS([for (pin : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [pin.name/],[pin.name/]_bool[/for]) =
	[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (not isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_POS([for (pin1 : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin1, aModel))] [pin1.name/][/for][for (pin1 : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (not isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])


				[/if]

[spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for]) =
		if not [for (constraint : ConstraintUse | spec.constraints)] [constraint.definition.name/]([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])[/for] then
			STOP
		else
			[spec.name/]
 
[spec.name/]_FULL = [spec.name/] ['['/]{| [for (pin : Pin | spec.inParameters)separator (',\n\t\t\t')][getPortUseFromPinSpec(pin, aModel)/][/for] |} || [getArchitectureName(aModel)/]_ALF ] [getArchitectureName(aModel)/]
		 
			[/if]

			[if (spec.name.toString().startsWith('SPEC_S_'))]
assert [spec.name/]_FULL ['[T='/] [getArchitectureName(aModel)/]

			[elseif (spec.name.toString().startsWith('SPEC_L_'))]

assert [spec.name/]_FULL:['[deadlock free[FD]]'/]
			[/if]

		[/let]
	 [let specEQ : ConstraintDef = self]
	 	[if (specEQ.name.toString().startsWith('SPEC'))]
[specEQ.name/]([for (pin : Pin | specEQ.inParameters)separator (',')] [pin.name/][/for])= [specEQ.getContraints(specEQ)/]
	 	[/if]
	 [/let]
	[/for]
[/for]

[for (behaviorExe : Allocation | aModel.allocation.allocs)? (behaviorExe.oclIsKindOf(ExecutableAllocation))]
print subset([behaviorExe.oclAsType(ExecutableAllocation).source.name/]_s,[for (constraint : ConstraintUse | behaviorExe.oclAsType(ExecutableAllocation).target.constraints)][constraint.definition.name/]_s[/for])
[/for]

[for (pck : Package | aModel.packages)]
	[for (elem : ElementDef | pck.definitions)]
		[let compDef : ComponentDef = self]
			[if (compDef.composite <> null)]
				[if (isEmpty_Delegations(compDef.composite))]
assert [compDef.name/]:['['/]deadlock free]
assert [compDef.name/]:['['/]livelock free]
				[/if]
			[/if]									
		[/let]
	[/for]
[/for]

[/file]
[elseif (ExistEqualsNames(aModel).toString().startsWith('Sucess:'))]
	[file ('sysadl2csp.csp', false, 'UTF-8')]
Error: Exit a duplicate port.
	[/file]
[elseif (CheckPortsAndPinsNames(aModel).toString().startsWith('Sucess:') = false)]
	[file ('sysadl2csp.csp', false, 'UTF-8')]
Error: The set of port and pin are not equals.
[CheckPortsAndPinsNames(aModel).toString()/]
	[/file]
[/if]
[/template]
