[comment encoding = UTF-8 /]
[module generate('http://org.sysadl')]
[import org::csp::translater::query::auxQuery /]

[template public generateModel(aModel : sysadl::Model)]
[comment @main/]
[if (ExistEqualsNames(aModel).toString().startsWith('Sucess') = false and CheckPortsAndPinsNames(aModel).toString().startsWith('Sucess'))]
[file ('sysadl2csp.csp', false, 'UTF-8')]
subset(s1, s2) = (inter(s1,s2)==s1)

MAX = 4

SysADLChar = {'a','b','c'}

FSeq(T,0) = {<>}
FSeq(T,1) = union( FSeq(T,0), {<z> | z <- T} )
FSeq(T,s) = {z^z'| z <- FSeq(T,1), z' <- FSeq(T,s-1)}

String = FSeq(SysADLChar,MAX)

	[for (pck : sysadl::Package | aModel.packages)]		
	[comment Types /]		
		[for (elem : ElementDef | pck.definitions)]
			[let unity : UnitDef = self]				
				[for (type : ElementDef | pck.definitions)? (type.oclIsKindOf(TypeDef))]
					[if (unity.name + '' + unity.dimension.name = type.name)]
[type.name/] = [getTypeUnity(type.oclAsType(TypeDef))/]						
					[/if]
				[/for]		
			[/let]			
			[let aux : Enumeration = self]
datatype [aux.name/] = [for (literal : EnumLiteralValue | aux.literals)separator ('|')][literal.name/][/for] 					
			[/let]		
			[let datatype : DataTypeDef = self]
[datatype.name/] = { [for (attribute : TypeUse | datatype.attributes)before ('(')separator(',')after (')')][attribute.name/][/for] | [for (attributeDef : TypeUse | datatype.attributes) separator (',')][attributeDef.name/]<- [if (attributeDef.definition.name = 'String')]String [elseif(attributeDef.definition.name = 'Boolean')]Bool[elseif(attributeDef.definition.name = 'Int')]{0 .. 5}[elseif(attributeDef.definition.name = 'Real')]Nat.Nat[else][attributeDef.definition.name/][/if] [/for] }
[for (attribute : TypeUse | datatype.attributes)separator ('\n')][datatype.name/]_[attribute.name/]([for (attribute : TypeUse | datatype.attributes)before ('(')separator(',')after (')')][attribute.name/][/for]) = [attribute.name/][/for]
			[/let]
		[/for]
	[/for]

	[comment channel/]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]			
			[let channel : ComponentDef = self]				
				[for (port : PortUse | channel.ports)]
					[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[port.definition.name/] : [getTypePort(port)/]						
					[elseif (port.definition.oclIsKindOf(sysadl::CompositePortDef))]
					[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports )]
						[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[compPort.name/]_[port.definition.name/] : [getTypePort(compPort)/]
						[/if]
					[/for]
					[/if]
				[/for]				
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let connector : ConnectorDef = self]
				[for (port : PortUse | connector.ports)]
					[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[port.definition.name/] : [getTypePort(port)/]						
					[elseif (port.definition.oclIsKindOf(sysadl::CompositePortDef))]
					[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports )]
						[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [port.name/]_[compPort.name/]_[port.definition.name/] : [getTypePort(compPort)/]
						[/if]
					[/for]
					[/if]
				[/for]
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = elem]					
				[if ( compDef.isBoundary = false and compDef.composite <> null)]		
					[for (compUse : ComponentUse| compDef.composite.components)]
						[for (portUse : PortUse | compUse.ports)]
							[if (portUse.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [compUse.name/]_[portUse.name/]_[portUse.definition.name/] : [getTypePort(portUse)/]
							[/if]
							[if (portUse.definition.oclIsKindOf(sysadl::CompositePortDef))]
							[for (compPort : PortUse | portUse.definition.oclAsType(sysadl::CompositePortDef).ports )]
								[if (compPort.definition.oclIsKindOf(sysadl::SimplePortDef))]
channel [compUse.name/]_[portUse.name/]_[compPort.name/]_[portUse.definition.name/] : [getTypePort(compPort)/]
								[/if]
							[/for]
							[/if]
						[/for]
					[/for]
				[/if]			
			[/let]
		[/for]
	[/for]


	[comment configuration/]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]
				[if (compDef.composite <> null)]
					[if (isEmpty_Delegations(compDef.composite))]
[compDef.name/] = 
['\t'/][compDef.name/]_config

[compDef.name/]_config = (Components_[compDef.name/] ['['/]| Sync_[compDef.name/] |] Connectors_[compDef.name/])\Internal_[compDef.name/]

Sync_[compDef.name/] = {| [for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')? (compUse.definition.composite = null)][for (portUse : PortUse | compUse.ports)separator (',')][compUse.name/]_[portUse.name/]_[portUse.definition.name/][/for][/for],
					[for (compUse : ComponentUse | compDef.composite.components)? (compUse.definition.isBoundary = false)][for (port : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')? (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))][compUse.name/]_[port.name/]_[port.definition.name/][/for][/for] |}

Internal_[compDef.name/] = {| [for (compUse : ComponentUse | compDef.composite.components)? (compUse.definition.isBoundary = false)][for (port : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')? (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))][compUse.name/]_[port.name/]_[port.definition.name/][/for][/for]|}

Components_[compDef.name/] = [for (compUse : ComponentUse | compDef.composite.components)separator ('\n\t\t\t\t\t\t|||')][compUse.definition.name/]['[['/][getRenamePortsComponent(compUse)/]]][/for]

Connectors_[compDef.name/] = [for (conn : ConnectorUse | compDef.composite.connectors)separator ('\n\t\t\t\t\t\t|||')][conn.definition.name/]['[['/][getRenamePortsConnector(conn, compDef)/]]][/for]
													
					[/if]					
				[/if]				
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]					
				[if ((compDef.composite <> null and isEmpty_Delegations(compDef.composite) = false))]
					
[compDef.name/]_config = (Components_[compDef.name/] ['['/]| Sync_[compDef.name/] |]  Connectors_[compDef.name/])\Internal_[compDef.name/]

Sync_[compDef.name/] = union(Internal_[compDef.name/], Delegation_Internal_[compDef.name/])

Internal_[compDef.name/] = {| [for (comp : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t\t')][for (port : PortUse | comp.ports)separator (',\n\t\t\t\t\t\t')][comp.name/]_[port.name/]_[port.definition.name/][/for][/for] |}

Components_[compDef.name/] = [for (comp : ComponentUse | compDef.composite.components)separator ('\n\t\t\t\t\t\t|||')][comp.definition.name/]['[['/][getRenamePortsComponent(comp)/]]][/for]

Connectors_[compDef.name/] = [for (conn : ConnectorUse | compDef.composite.connectors)separator ('\n\t\t\t\t\t\t|||')after ('\n\t\t\t\t\t\t|||')][conn.definition.name/]['[['/][getRenamePortsConnector(conn, compDef)/]]][/for]Delegation_[compDef.name/]			
															
				[/if]							
			[/let]			
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]					
				[if ((compDef.composite <> null and isEmpty_Delegations(compDef.composite)))]
					[for (compUse : ComponentUse | compDef.composite.components)? (compUse.definition.composite <> null)]						
Delegation_Internal_[compUse.definition.name/] = {|[for (port : PortUse | compUse.ports)separator (',\n\t\t\t\t\t\t\t\t\t\t\t')][compUse.name/]_[port.name/]_[port.definition.name/][/for] |}

Delegation_[compUse.definition.name/] = [for (del : Delegation | compUse.definition.composite.delegations)separator ('\n\t\t\t\t|||')][if (del.source.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))][del.destination.name/]_to_[del.source.name/]['[['/][getRenamePortsDelegation(del, compUse)/]]][elseif (del.source.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))][del.source.name/]_to_[del.destination.name/]['[['/][getRenamePortsDelegation(del, compUse)/]]][/if][/for]												
					[/for]					
				[/if]							
			[/let]			
		[/for]
	[/for]

	[comment components/]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]
				[if (((compDef.composite <> null) and isEmpty_Delegations(compDef.composite) = false))]										
[compDef.name/] =
	[compDef.name/]_config																	
				[/if]				
				[if (compDef.composite = null and compDef.isBoundary = true)]												
[compDef.name/] = 
					[for (port : PortUse | compDef.ports)]								
						[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
							[if (port.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('in'))]
	['\t'/][port.name/]_[port.definition.name/]?[port.name/] ->
							[/if]
						[else]
							[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports)]
								[if (compPort.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('in'))]
	['\t'/][port.name/]_[compPort.name/]_[port.definition.name/]?[compPort.name/] ->
								[/if]
							[/for]
						[/if]
					[/for]
					[for (port : PortUse | compDef.ports)]								
						[if (port.definition.oclIsKindOf(sysadl::SimplePortDef))]
							[if (port.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('out'))]
['\t'/]|~| [port.name/]:[getTypePort(port)/] @ [port.name/]_[port.definition.name/]![port.name/] ->
							[/if]
						[else]
							[for (compPort : PortUse | port.definition.oclAsType(sysadl::CompositePortDef).ports)]
								[if (compPort.definition.oclAsType(sysadl::SimplePortDef).flowProperties.toString().contains('out'))]
['\t'/]|~|[compPort.name/]:[getTypePort(port)/] @ [port.name/]_[compPort.name/]_[port.definition.name/]![compPort.name/] ->
								[/if]
							[/for]
						[/if]
					[/for]
[compDef.name/]
								
				[elseif(compDef.composite = null and compDef.isBoundary = false)]
[compDef.name/] =								
['\t'/][getActivityToStructure(compDef, aModel.allocation)/]				
				[/if]
			[/let]
		[/for]
	[/for]

	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let connDef : ConnectorDef = self]
[connDef.name/] = 
				[if (connDef.getActivityToStructure(connDef, aModel.allocation) = '')]								
					[for (port : PortUse | connDef.ports)]
						[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))]
		[port.name/]_[port.definition.oclAsType(SimplePortDef).name/]?out ->
						[/if]
					[/for]
					[for (port : PortUse | connDef.ports)]
						[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))]
		[port.name/]_[port.definition.oclAsType(SimplePortDef).name/]!out ->
						[/if]
					[/for]
[connDef.name/]

				[else]
		[connDef.getActivityToStructure(connDef, aModel.allocation)/]

				[/if]
			[/let]
		[/for]
	[/for]

	[comment delegations /]	
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let compDef : ComponentDef = self]
				[if (compDef.composite <> null)]					
						[for (del : Delegation | compDef.composite.delegations)]
							[if (del.source.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))]
[del.destination.name/]_to_[del.source.name/] =
	[del.destination.name/]_[del.destination.definition.name/]?[del.destination.definition.name/] ->
	[for (compUse : ComponentUse | compDef.composite.components)][for (portUse : PortUse | compUse.ports)][if (portUse.name = del.source.name and portUse.definition.name = del.source.definition.name)][compUse.name/]_[del.source.name/]_[del.source.definition.name/]![del.source.definition.name/] ->[/if][/for][/for]
[del.destination.name/]_to_[del.source.name/]
							[elseif (del.source.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))]
[del.source.name/]_to_[del.destination.name/] =	
	[for (compUse : ComponentUse | compDef.composite.components)][for (portUse : PortUse | compUse.ports)][if (portUse.name = del.source.name and portUse.definition.name = del.source.definition.name)][compUse.name/]_[del.source.name/]_[del.source.definition.name/]?[del.source.definition.name/] ->[/if][/for][/for]
	[del.destination.name/]_[del.destination.definition.name/]![del.destination.definition.name/] ->
[del.source.name/]_to_[del.destination.name/]						
							[/if]						
						[/for]
					[/if]								
			[/let]
		[/for]
	[/for]

	[comment activities /]	
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let activity : ActivityDef = self]
				[if (not activity.name.toString().startsWith('SPEC'))]
					
				
				[for (flow : ActivityRelation | activity._body.flows)]
					[if (flow.target.oclIsKindOf(Pin) and flow.oclIsKindOf(ActivityFlow))]
channel [flow.target.oclAsType(Pin).name/]_[flow.target.oclAsType(Pin).definition.name/] : [getTypePin(flow.target.oclAsType(Pin))/]		
					[else]
channel [flow.source.oclAsType(Pin).name/]_[flow.source.oclAsType(Pin).definition.name/] : [getTypePin(flow.source.oclAsType(Pin))/]
					[/if]
				[/for]

Sync_[activity.name/] = union(Internal_[activity.name/], Port_[activity.name/]) 

Internal_[activity.name/] = {|[for (flow : ActivityRelation | activity._body.flows )separator (',\n\t\t\t\t\t')][if (flow.target.oclIsKindOf(Pin) and flow.oclIsKindOf(ActivityFlow))][flow.target.oclAsType(Pin).name/]_[flow.target.oclAsType(Pin).definition.name/][else][flow.source.oclAsType(Pin).name/]_[flow.source.oclAsType(Pin).definition.name/][/if][/for] |}

Port_[activity.name/] = {| [for (alloc : Allocation | aModel.allocation.allocs)? (alloc.oclIsKindOf(ActivityAllocation))][if ((alloc.oclAsType(ActivityAllocation).source.name = activity.name) and (alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ComponentDef)))][getPortsActivities(pck,alloc.oclAsType(ActivityAllocation).target, alloc)/][elseif (alloc.oclAsType(ActivityAllocation).source.name = activity.name and alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ConnectorDef))][getPortsActivities(pck, alloc.oclAsType(ActivityAllocation).target, alloc)/][/if][/for] |}

[activity.name/] = (Pins_[activity.name/] ['['/]| Sync_[activity.name/] |]  Actions_[activity.name/])\Internal_[activity.name/]

Pins_[activity.name/] = ['['/]| Sync_[activity.name/]|] i : {1 .. [getPinListSize(activity)/]} @ Pins_[activity.name/]_Func(i)

Actions_[activity.name/] = ['['/]| Sync_[activity.name/] |] i : {1 .. [getActionListSize(activity)/]} @ Actions_[activity.name/]_Func(i)

[getPinFunction(activity, 'Pins')/]

				[for (pin : Pin | activity.inParameters)]
[pin.name/]_[activity.name/] =
[for (alloc : Allocation | aModel.allocation.allocs)? (alloc.oclIsKindOf(ActivityAllocation))]	
	[if (alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ComponentDef) and activity.name = alloc.oclAsType(ActivityAllocation).source.name)]
		[for (port : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ComponentDef).ports)]
			[if (port.name = pin.name)]
['\t'/][port.name/]_[port.definition.name/]?[port.name/] ->	
			[/if]			
		[/for]
	[elseif (alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ConnectorDef) and activity.name = alloc.oclAsType(ActivityAllocation).source.name)]
		[for (port : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ConnectorDef).ports)]
			[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('out'))]
['\t'/][port.name/]_[port.definition.name/]?[pin.name/] ->
			[/if]
		[/for]	
	[/if]	
[/for]
['\t'/][pin.name/]_[pin.definition.name/]![pin.name/] ->
[pin.name/]_[activity.name/]				
				[/for]

				[for (pin : Pin | activity.outParameters)]
[pin.name/]_[activity.name/] = 
['\t'/][pin.name/]_[pin.definition.name/]?[pin.name/] ->
[for (alloc : Allocation | aModel.allocation.allocs)? (alloc.oclIsKindOf(ActivityAllocation))]	
	[if (alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ComponentDef) and activity.name = alloc.oclAsType(ActivityAllocation).source.name)]
		[for (port : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ComponentDef).ports)]
			[if (port.name = pin.name)]
['\t'/][port.name/]_[port.definition.name/]![port.name/] ->	
			[/if]			
		[/for]
	[elseif (alloc.oclAsType(ActivityAllocation).target.oclIsKindOf(ConnectorDef) and activity.name = alloc.oclAsType(ActivityAllocation).source.name)]
		[for (port : PortUse | alloc.oclAsType(ActivityAllocation).target.oclAsType(ConnectorDef).ports)]
			[if (port.definition.oclAsType(SimplePortDef).flowProperties.toString().contains('in'))]
['\t'/][port.name/]_[port.definition.name/]![pin.name/] ->
			[/if]
		[/for]	
	[/if]	
[/for]
[pin.name/]_[activity.name/]
				[/for]

[getActionFunction(activity, 'Actions')/]

				[for (action : ActionUse | activity._body.actions)]
[action.name/]_[action.definition.name/] = 
['\t'/][getActionBody(activity,action)/]
[action.name/]_[action.definition.name/]
				[/for]
				[/if]
			[/let]
		[/for]
	[/for]

[comment Constraint /]
	[for (pck : sysadl::Package | aModel.packages)]				
		[for (elem : ElementDef | pck.definitions)]
			[let constraint : ConstraintDef = self]
				[if (not constraint.name.toString().startsWith('SPEC'))]					
[constraint.name/]([if (constraint.inParameters <> null)]x[/if][for (param : Pin | constraint.inParameters)before (',')separator (',')][param.name/][/for]) = [constraint.getContraints(constraint)/]

[constraint.name/]_check = 
			{([for (paramIn : Pin | constraint.inParameters)separator (', ')]
[paramIn.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/] <- [getTypePin(paramIn)/] [/for], 
						not ({[for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for] | [for (out : Pin | constraint.outParameters)separator (',')][out.name/] <- [getTypePin(out)/][/for],
							[constraint.name/]([for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for],[for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for])} == {})}
			==
			{([for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (', ')][paramIn.name/] <- [getTypePin(paramIn)/][/for]}

print [constraint.name/]_check

[constraint.name/]_s = 
			{([for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for],[for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for]) | [for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/] <- [getTypePin(paramIn)/][/for],
['\t\t\t'/][for (out : Pin | constraint.outParameters)separator (',')][out.name/] <- [getTypePin(out)/][/for],
['\t\t\t'/][constraint.name/]([for (out : Pin | constraint.outParameters)separator (',')][out.name/][/for],[for (paramIn : Pin | constraint.inParameters)separator (',')][paramIn.name/][/for])}  
			[/if]			
		[/let]
[comment execution /]
			[let exe: Executable = self]
[exe.name/]([for (param : TypeUse | exe.params)separator (',')][param.name/][/for])= [exe.getExecution(exe)/]

[exe.name/]_s = 
			{([for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/][/for],[for (out : TypeDef | exe.returnType)separator (',')][out.name/][/for]) | [for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/] <- [getTypeCSP(paramIn.definition)/][/for],
['\t\t\t'/][for (out : TypeDef | exe.returnType)separator (',')][out.name/] <- [getTypeCSP(out)/][/for],
['\t\t\t'/][exe.returnType.name/] == [exe.name/]([for (paramIn : TypeUse | exe.params)separator (',')][paramIn.name/][/for])}

			[/let]
		[/for]
	[/for]
channel ERROR
[for (pck : Package | aModel.packages)]
	[for (elem : ElementDef | pck.definitions)]
		[let compDef : ComponentDef = elem]					
			[if (compDef.composite <> null and isEmpty_Delegations(compDef.composite))]
[compDef.name/]_ALF = {|[for (compUse : ComponentUse | compDef.composite.components)separator (',\n\t\t\t\t\t')after ('|}')][for (portUse : PortUse | compUse.ports)separator (',\n\t\t\t\t\t')][compUse.name/]_[portUse.name/]_[portUse.definition.name/][/for][/for]
			[/if]		
		[/let]
		[let spec : ActionDef = self]
			[if (spec.name.toString().startsWith('SPEC_'))]
				[if (existPinOfPortOPT(spec, aModel) =  1 )]
[spec.name/] =	[spec.name/]_IN([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/], false[/for])
[spec.name/]_IN([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [pin.name/], [pin.name/]_bool[/for]) = 
				[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_IN([for (pin1 : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
([for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for])[spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])					
				
				[elseif (existPinOfPortOPT(spec, aModel) =  0)]

[spec.name/] =	[spec.name/]_OUT([for (pin : Pin | spec.inParameters)? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/],false[/for])			
[spec.name/]_OUT([for (pin : Pin | spec.inParameters)? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [pin.name/],[pin.name/]_bool[/for]) =
	[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (not isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_OUT([for (pin1 : Pin | spec.inParameters)? (isPinFromPortIn(pin1, aModel))] [pin1.name/][/for][for (pin1 : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (not isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])

				[elseif (existPinOfPortOPT(spec, aModel) =  2)]

[spec.name/] =	[spec.name/]_IN([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/], false[/for])

[spec.name/]_IN([for (pin : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin, aModel))] [pin.name/], [pin.name/]_bool[/for]) = 
				[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_IN([for (pin1 : Pin | spec.inParameters)separator (',')? (isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_OUT([for (pin : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [getDefaultValueType(pin)/],false[/for]) 
			
[spec.name/]_OUT([for (pin : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin, aModel))] [pin.name/][/for][for (pin : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin, aModel))] [pin.name/],[pin.name/]_bool[/for]) =
	[for (pin : Pin | spec.inParameters)separator ('[]\n')after ('[]\n')? (not isPinFromPortIn(pin, aModel))]
not([pin.name/]_bool) & [getPortUseFromPinSpec(pin, aModel)/]?[pin.definition.name.toString().toLower()/] -> [spec.name/]_OUT([for (pin1 : Pin | spec.inParameters)separator (',')after (',')? (isPinFromPortIn(pin1, aModel))] [pin1.name/][/for][for (pin1 : Pin | spec.inParameters)separator (',')? (not isPinFromPortIn(pin1, aModel))] [if(pin.name = pin1.name)] [pin.definition.name.toString().toLower()/], true [else] [pin1.name/], [pin1.name/]_bool [/if][/for]) 
				[/for]
[for (pin : Pin | spec.inParameters)separator (' & ')after (' & ')? (not isPinFromPortIn(pin, aModel))][pin.name/]_bool[/for][spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])


				[/if]

[spec.name/]_v([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for]) =
		if not [for (constraint : ConstraintUse | spec.constraints)] [constraint.definition.name/]([for (pin : Pin | spec.inParameters)separator (',')][pin.name/][/for])[/for] then
			STOP
		else
			[spec.name/]
 
[spec.name/]_FULL = [spec.name/] ['['/]{| [for (pin : Pin | spec.inParameters)separator (',\n\t\t\t')][getPortUseFromPinSpec(pin, aModel)/][/for] |} || [getArchitectureName(aModel)/]_ALF ] [getArchitectureName(aModel)/]
		 
			[/if]

			[if (spec.name.toString().startsWith('SPEC_S_'))]
assert [getArchitectureName(aModel)/] ['[T='/] [spec.name/]_FULL

			[elseif (spec.name.toString().startsWith('SPEC_L_'))]

assert [spec.name/]_FULL:['[deadlock free[FD]]'/]
			[/if]

		[/let]
	 [let specEQ : ConstraintDef = self]
	 	[if (specEQ.name.toString().startsWith('SPEC'))]
[specEQ.name/]([for (pin : Pin | specEQ.inParameters)separator (',')] [pin.name/][/for])= [specEQ.getContraints(specEQ)/]
	 	[/if]
	 [/let]
	[/for]
[/for]

[for (behaviorExe : Allocation | aModel.allocation.allocs)? (behaviorExe.oclIsKindOf(ExecutableAllocation))]
print subset([behaviorExe.oclAsType(ExecutableAllocation).source.name/]_s,[for (constraint : ConstraintUse | behaviorExe.oclAsType(ExecutableAllocation).target.constraints)][constraint.definition.name/]_s[/for])
[/for]

[for (pck : Package | aModel.packages)]
	[for (elem : ElementDef | pck.definitions)]
		[let compDef : ComponentDef = self]
			[if (compDef.composite <> null)]
				[if (isEmpty_Delegations(compDef.composite))]
assert [compDef.name/]:['['/]deadlock free]
assert [compDef.name/]:['['/]livelock free]
				[/if]
			[/if]									
		[/let]
	[/for]
[/for]

[/file]
[elseif (ExistEqualsNames(aModel).toString().startsWith('Sucess:'))]
	[file ('sysadl2csp.csp', false, 'UTF-8')]
Error: Exit a duplicate port.
	[/file]
[elseif (CheckPortsAndPinsNames(aModel).toString().startsWith('Sucess:') = false)]
	[file ('sysadl2csp.csp', false, 'UTF-8')]
Error: The set of port and pin are not equals.
[CheckPortsAndPinsNames(aModel).toString()/]
	[/file]
[/if]
[/template]
