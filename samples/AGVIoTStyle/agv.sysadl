Model SysADLArchitecture ; 
package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } 
	
datatype VehicleData { attributes : id : Int ; destination : Int ; operation : CmdArm ; location : Int ; status : Availability ; } enum CmdArm { load , unload } enum Availability { busy , idle } enum CmdMotor { start , stop } enum NotificationMotor { started , stopped } enum NotificationAGV { departed , arrived , passed } enum NotificationArm { loaded , unloaded } datatype ArrivedStation { attributes : location : Int ; } }
package Ports{ import SysADL.types ; port def VehicleDataOPT { flow out VehicleData } port def VehicleDataIPT { flow in VehicleData } port def CmdMotorOPT { flow out CmdMotor } port def CmdMotorIPT { flow in CmdMotor } port def NotificationMotorOPT { flow out NotificationMotor } port def NotificationMotorIPT { flow in NotificationMotor } port def MotorCPT { ports : cmdIn : CmdMotorIPT ; nOut : NotificationMotorOPT ; } port def AGVtoMotorCPT { ports : cmdOut : CmdMotorOPT ; nIn : NotificationMotorIPT ; } port def NotificationAGVOPT { flow out NotificationAGV } port def NotificationAGVIPT { flow in NotificationAGV } port def CmdArmOPT { flow out CmdArm } port def CmdArmIPT { flow in CmdArm } port def NotificationArmOPT { flow out NotificationArm } port def NotificationArmIPT { flow in NotificationArm } port def AGVtoArmCPT { ports : cmdOut : CmdArmOPT ; nIn : NotificationArmIPT ; } port def ArmCPT { ports : cmdIn : CmdArmIPT ; nOut : NotificationArmOPT ; } port def ArrivedSensorOPT { flow out ArrivedStation } port def ArrivedSensorIPT { flow in ArrivedStation } port def signalClockOPT { flow out Void } port def signalClockIPT { flow in Void } port def SupervisorySystemCTP { ports : nIn : NotificationAGVIPT ; vdOut : VehicleDataOPT ; } port def AGVtoSupervisoryCPT { ports : nOut : NotificationAGVOPT ; vdIn : VehicleDataIPT ; } port def idOPT { flow out Int } port def idIPT { flow in Int } port def ReturnVehicleDataCPT { ports : idAGV : idIPT ; vd : VehicleDataOPT ; } port def QueryVehicleDataCPT { ports : vd : VehicleDataIPT ; idAGV : idOPT ; } }
package Connectors { import Ports ;
	connector def CmdMotorCN {
		participants : ~ cmOut : CmdMotorOPT ; ~ cmIn : CmdMotorIPT ; flows : CmdMotor from cmOut to cmIn 
	}
	connector def NotificationMotorCN {
		participants : ~ nmOut : NotificationMotorOPT ; ~ nmIn : NotificationMotorIPT ; flows : NotificationMotor from nmOut to nmIn 
	}
connector def MotorCN { participants : ~ agvm : AGVtoMotorCPT ; ~ m : MotorCPT ; configuration { } } connector def VehicleDataCN { participants : ~ vdOut : VehicleDataOPT ; ~ vdIn : VehicleDataIPT ; flows : VehicleData from vdOut to vdIn } connector def NotificationAGVCN { participants : ~ nAGVOut : NotificationAGVOPT ; ~ nAGVIn : NotificationAGVIPT ; flows : NotificationAGV from nAGVOut to nAGVIn } connector def SupervisorySystemCN { participants : ~ ss : SupervisorySystemCTP ; ~ agvs : AGVtoSupervisoryCPT ; configuration { } } connector def CmdArmCN { participants : ~ caOut : CmdArmOPT ; ~ caIn : CmdArmIPT ; flows : CmdArm from caOut to caIn } connector def NotificationArmCN { participants : ~ naOut : NotificationArmOPT ; ~ naIn : NotificationArmIPT ; flows : NotificationArm from naOut to naIn } connector def ArmCN { participants : ~ a : ArmCPT ; ~ agva : AGVtoArmCPT ; configuration { } } connector def ArrivedSensorCN { participants : ~ asOut : ArrivedSensorOPT ; ~ asIn : ArrivedSensorIPT ; flows : ArrivedStation from asOut to asIn } connector def signalClockCN { participants : ~ scOut : signalClockOPT ; ~ scIn : signalClockIPT ; flows : Void from scOut to scIn } connector def VehicleStatusCN { participants : ~ rvd : ReturnVehicleDataCPT ; ~ qvd : QueryVehicleDataCPT ; configuration { } } connector def IdAGVCN { participants : ~ idOut : idOPT ; ~ idIn : idIPT ; flows : Int from idOut to idIn } }
package Components satisfies IoTStyle { import Ports ; import Connectors ; import SysADL.types ; boundary
	component def SupervisorySystem { ports : supervisoryProxy : SupervisorySystemCTP ; } boundary
	component def DisplaySystem { ports : displayProxy : VehicleDataIPT ; }
	component def VehicleControl { ports : moveIn : VehicleDataIPT ; motorInterface : AGVtoMotorCPT ; armInterface : AGVtoArmCPT ; sensorInterface : ArrivedSensorIPT ; nOut : NotificationAGVOPT ;  updateData : VehicleDataOPT ; }
	component def AGVSystem { configuration { components : agv : AGV { using ports : supervisoryProxy : AGVtoSupervisoryCPT ; displayProxy : VehicleDataOPT ; } ss : SupervisorySystem { using ports : supervisorySProxy : SupervisorySystemCTP ; } ds : DisplaySystem { using ports : displaySProxy : VehicleDataIPT ; } connectors : ss : SupervisorySystemCN bindings supervisorySProxy = supervisoryProxy ; status : VehicleDataCN bindings displayProxy = displaySProxy ; } }
	component def AGV implements IoTStyle.Device { ports : supervisoryProxy : AGVtoSupervisoryCPT ; displayProxy : VehicleDataOPT ; configuration { components : c : Clock { using ports : scO : signalClockOPT ; } vt : VehicleTimer { using ports : scI : signalClockIPT ; sOut : VehicleDataOPT ; qstatus : QueryVehicleDataCPT ; } ra : RoboticArm { using ports : arm : ArmCPT ; } m : Motor { using ports : m : MotorCPT ; } as : ArrivedSensor { using ports : as : ArrivedSensorOPT ; } vc : VehicleControl { using ports : moveIn : VehicleDataIPT ; motorInterface : AGVtoMotorCPT ; armInterface : AGVtoArmCPT ; sensorInterface : ArrivedSensorIPT ; nOut : NotificationAGVOPT ;  updateData : VehicleDataOPT ; } vs : VehicleStatus { using ports : dataIn : VehicleDataIPT ; rvd : ReturnVehicleDataCPT ; } connectors : sc : signalClockCN bindings scO = scI ; m : MotorCN bindings motorInterface = m ; as : ArrivedSensorCN bindings as = sensorInterface ; a : ArmCN bindings armInterface = arm ; vd : VehicleDataCN bindings updateData = dataIn ; status : VehicleStatusCN bindings rvd = qstatus ;  delegations : sOut to displayProxy moveIn to vdIn nOut to nOut } } boundary
	component def Motor implements IoTStyle.Actuator { ports : m : MotorCPT concrete IoTStyle.Actuator.actuatorIPT ; } boundary
	component def ArrivedSensor implements IoTStyle.Sensor { ports : as : ArrivedSensorOPT concrete IoTStyle.Sensor.sensorOPT ; } boundary
	component def RoboticArm implements IoTStyle.Actuator { ports : arm : ArmCPT concrete IoTStyle.Actuator.actuatorIPT ; } boundary
	component def VehicleStatus implements IoTStyle.Datastore { ports : dataIn : VehicleDataIPT concrete IoTStyle.Datastore.dataIPT ; rvd : ReturnVehicleDataCPT concrete IoTStyle.Datastore.dataOPT ; }
	component def VehicleTimer { ports : sc : signalClockIPT ; sOut : VehicleDataOPT ; qvd : QueryVehicleDataCPT ; } boundary
	component def Clock { ports : sc : signalClockOPT ; } 
	activity def VehicleControlAC ( moveIn : VehicleData , nMotorIn : NotificationMotor , asIn : ArrivedStation ,  nArmIn : NotificationArm ) : ( cmdMotorOut : CmdMotor , nAGVOut : NotificationAGV , updateData : VehicleData ,  cmdArmOut : CmdArm ) {
		body {
			actions : mc : MotorControlAN { using pins : moveIn : VehicleData ; }
			ud : UpdateDataAN { using pins : vd : VehicleData ; nMotor : NotificationMotor ; } 
			nm : NotificationMotorAN { using pins : nMotorIn : NotificationMotor ; } 
			 
			ac : ArmControlAN { using pins : vdIn : VehicleData ; stopMotor : CmdMotor ; } 
			na : NotificationArmAN { using pins : nArmIn : NotificationArm ; } 
			sc : SensorControlAN { using pins : asIn : ArrivedStation ; vdt : VehicleData ; } sis : SetIdleStatusAN { using pins : v : VehicleData ; nArm : NotificationArm ; } sp : SetPassedAN { using pins : vdata : VehicleData ; } 
			delegate moveIn to VehicleData
			delegate cmdMotorOut to mc
			delegate updateData to ud
			delegate nMotorIn to NotificationMotor
			delegate nAGVOut to sp
			delegate nAGVOut to nm
			delegate asIn to asIn
			
			delegate cmdArmOut to ac
			delegate nArmIn to nArmIn
			delegate nAGVOut to na
			delegate nArmIn to nArm
			delegate updateData to sis			
			delegate updateData to sc
			flow from sc to switch {case 'sc->destination' == 'sc->location' : vdIn, case 'sc->destination' != 'sc->location' : vdata} 
		flow from VehicleData to vd flow from VehicleData to moveIn flow from VehicleData to vdt flow from ud to VehicleData flow from sc to VehicleData flow from NotificationMotor to nMotorIn flow from NotificationMotor to nMotor 
		flow from VehicleData to v
		flow from mc to stopMotor  datastore VehicleData : VehicleData datastore NotificationMotor : NotificationMotor }
	}
	action def MotorControlAN ( moveIn : VehicleData ) : CmdMotor { constraint : post-condition MotorControlEQ } action def NotificationMotorAN ( nMotorIn : NotificationMotor ) : NotificationAGV { constraint : post-condition NotificationMotorEQ }  
	action def ArmControlAN ( vdIn : VehicleData , stopMotor : CmdMotor ) : CmdArm { constraint : post-condition ArmControlEQ } 
	action def UpdateDataAN ( vd : VehicleData , nMotor : NotificationMotor ) : VehicleData { constraint : post-condition UpdateDataEQ } action def NotificationArmAN ( nArmIn : NotificationArm ) : NotificationAGV { constraint : post-condition NotificationArmEQ } action def SensorControlAN ( asIn : ArrivedStation , vdt : VehicleData ) : VehicleData { constraint : post-condition SensorControlEQ } 
	constraint MotorControlEQ ( moveIn : VehicleData ) : ( cmdMotorOut : CmdMotor ) { 
		equation = 'moveIn->destination != moveIn->location' ? cmdMotorOut == CmdMotor::start : cmdMotorOut == CmdMotor::stop
	} 
	constraint NotificationMotorEQ ( nMotorIn : NotificationMotor ) : ( nAGVOut : NotificationAGV ) { 
		equation = nMotorIn == NotificationMotor::started implies nAGVOut == NotificationAGV::departed
	} 
	constraint UpdateDataEQ ( vd : VehicleData , inMotor : NotificationMotor ) : ( updateData : VehicleData ) { 
		equation = 'updateData->id == vd->id && updateData->destination == vd->destination && updateData->operation == vd->operation && updateData->location == vd->location' && (inMotor == NotificationMotor::started  implies 'updateData->status' == Availability::busy)} 
		constraint SensorControlEQ ( asIn : ArrivedStation , vdt : VehicleData ) : ( updateData : VehicleData ) { 
			equation = 'updateData->id == vdt->id && updateData->destination == vdt->destination && updateData->operation == vdt->operation && updateData->location == asIn->location'
		} 
		constraint ArmControlEQ ( vdIn : VehicleData, stopMotor : CmdMotor ) : ( cmdArmOut : CmdArm ) { 
			equation = stopMotor == CmdMotor::stop implies cmdArmOut == 'vdIn->operation'
		} 
		constraint NotificationArmEQ ( nArmIn : NotificationArm ) : ( nAGVOut : NotificationAGV ) { 
			equation = nAGVOut == NotificationAGV::arrived
		} action def SetIdleStatusAN ( v : VehicleData , nArm : NotificationArm ) : VehicleData { constraint : post-condition SetIdleStatusEQ } 
		constraint SetIdleStatusEQ ( vd : VehicleData , inArm : NotificationArm ) : ( updateData : VehicleData ) { 
			equation = 'updateData->id == vd->id && updateData->destination == vd->destination && updateData->operation == vd->operation && updateData->location == vd->location && updateData->status' == Availability::idle
		} action def SetPassedAN ( vdata : VehicleData ) : NotificationAGV { 
			constraint : post-condition SetPassedEQ
		} constraint SetPassedEQ ( vdata : VehicleData ) : ( nAGVOut : NotificationAGV ) { 
			equation = nAGVOut == NotificationAGV::passed
		} activity def VehicleTimerAC ( signalClock : Void , vd : VehicleData ) : ( idAGV : Int , vdOut : VehicleData ) { 
			body { 
				actions : qs : QueryStatusAN { using pins : signalClock : Void ; } ss : SendStatusAN { using pins : vdIn : VehicleData ; }
				delegate idAGV to qs
				delegate signalClock to signalClock
				delegate vd to vdIn
				delegate vdOut to ss 
			}
		} action def QueryStatusAN ( signalClock : Void ) : Int { } action def SendStatusAN ( vdIn : VehicleData ) : VehicleData { } }
style IoTStyle { abstract component def Sensor { ports : sensorOPT : out any } abstract component def Actuator { ports : actuatorIPT : in any } abstract component def Device { ports : sensorIPT : in any deviceOPT : out any actuatorOPT : out any gtwDataIPT : in any } abstract component def Gateway { ports : deviceIPT : in any gtwDataOPT : out any serviceIPT : in any serviceOPT : out any } abstract component def Datastore { ports : dataIPT : in any dataOPT : out any } }