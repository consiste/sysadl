/*
 * generated by Xtext 2.10.0
 */
package br.consiste.serializer;

import br.consiste.services.SysADLGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sysADL_Sintax.ActionDef;
import sysADL_Sintax.ActionReceive;
import sysADL_Sintax.ActionSend;
import sysADL_Sintax.ActionUse;
import sysADL_Sintax.ActivityAllocation;
import sysADL_Sintax.ActivityBody;
import sysADL_Sintax.ActivityDef;
import sysADL_Sintax.ActivityDelegation;
import sysADL_Sintax.ActivityFlow;
import sysADL_Sintax.ActivitySwitch;
import sysADL_Sintax.ActivitySwitchCase;
import sysADL_Sintax.AllocationTable;
import sysADL_Sintax.ArithmeticExpression;
import sysADL_Sintax.BlockStatement;
import sysADL_Sintax.BooleanLiteralExpression;
import sysADL_Sintax.ClassificationExpression;
import sysADL_Sintax.ComponentDef;
import sysADL_Sintax.ComponentUse;
import sysADL_Sintax.CompositePortDef;
import sysADL_Sintax.ConditionalLogicalExpression;
import sysADL_Sintax.ConditionalTestExpression;
import sysADL_Sintax.Configuration;
import sysADL_Sintax.ConnectorBinding;
import sysADL_Sintax.ConnectorDef;
import sysADL_Sintax.ConnectorUse;
import sysADL_Sintax.ConstraintDef;
import sysADL_Sintax.ConstraintUse;
import sysADL_Sintax.DataBuffer;
import sysADL_Sintax.DataStore;
import sysADL_Sintax.DataTypeDef;
import sysADL_Sintax.DefaultSwitchClause;
import sysADL_Sintax.Delegation;
import sysADL_Sintax.DimensionDef;
import sysADL_Sintax.DoStatement;
import sysADL_Sintax.ElseStatement;
import sysADL_Sintax.EnumLiteralValue;
import sysADL_Sintax.Enumeration;
import sysADL_Sintax.Executable;
import sysADL_Sintax.ExecutableAllocation;
import sysADL_Sintax.Expression;
import sysADL_Sintax.Flow;
import sysADL_Sintax.ForControl;
import sysADL_Sintax.ForStatement;
import sysADL_Sintax.IfBlockStatement;
import sysADL_Sintax.IfStatement;
import sysADL_Sintax.LogicalExpression;
import sysADL_Sintax.Model;
import sysADL_Sintax.NameExpression;
import sysADL_Sintax.NaturalLiteralExpression;
import sysADL_Sintax.Pin;
import sysADL_Sintax.PortUse;
import sysADL_Sintax.Property;
import sysADL_Sintax.PropertyAccessExpression;
import sysADL_Sintax.Protocol;
import sysADL_Sintax.ProtocolBody;
import sysADL_Sintax.RelationalExpression;
import sysADL_Sintax.Requirement;
import sysADL_Sintax.ReturnStatement;
import sysADL_Sintax.ShiftExpression;
import sysADL_Sintax.SimplePortDef;
import sysADL_Sintax.StringLiteralExpression;
import sysADL_Sintax.SwitchClause;
import sysADL_Sintax.SwitchStatement;
import sysADL_Sintax.SysADLPackage;
import sysADL_Sintax.ThisExpression;
import sysADL_Sintax.TypeUse;
import sysADL_Sintax.UnitDef;
import sysADL_Sintax.ValueTypeDef;
import sysADL_Sintax.VariableDecl;
import sysADL_Sintax.WhileStatement;

@SuppressWarnings("all")
public class SysADLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SysADLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SysADLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SysADLPackage.ACTION_DEF:
				sequence_ActionDef(context, (ActionDef) semanticObject); 
				return; 
			case SysADLPackage.ACTION_RECEIVE:
				sequence_ActionReceive(context, (ActionReceive) semanticObject); 
				return; 
			case SysADLPackage.ACTION_SEND:
				sequence_ActionSend(context, (ActionSend) semanticObject); 
				return; 
			case SysADLPackage.ACTION_USE:
				sequence_ActionUse(context, (ActionUse) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_ALLOCATION:
				sequence_ActivityAllocation(context, (ActivityAllocation) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_BODY:
				sequence_ActivityBody(context, (ActivityBody) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_DEF:
				sequence_ActivityDef(context, (ActivityDef) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_DELEGATION:
				sequence_ActivityDelegation(context, (ActivityDelegation) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_FLOW:
				sequence_ActivityFlow(context, (ActivityFlow) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_SWITCH:
				sequence_ActivitySwitch(context, (ActivitySwitch) semanticObject); 
				return; 
			case SysADLPackage.ACTIVITY_SWITCH_CASE:
				sequence_ActivitySwitchCase(context, (ActivitySwitchCase) semanticObject); 
				return; 
			case SysADLPackage.ALLOCATION_TABLE:
				sequence_AllocationTable(context, (AllocationTable) semanticObject); 
				return; 
			case SysADLPackage.ARITHMETIC_EXPRESSION:
				if (rule == grammarAccess.getAdditiveExpressionRule()) {
					sequence_AdditiveExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getNonBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getNonNameExpressionRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getConditionalAndOrConditionalOrExpressionRule()
						|| rule == grammarAccess.getInclusiveOrOrConditionalAndExpressionRule()
						|| rule == grammarAccess.getExclusiveOrOrInclusiveOrExpressionRule()
						|| rule == grammarAccess.getAndOrExclusiveOrExpressionRule()
						|| rule == grammarAccess.getEqualityOrAndExpressionRule()
						|| rule == grammarAccess.getClassificationOrEqualityExpressionRule()
						|| rule == grammarAccess.getRelationalOrClassificationExpressionRule()
						|| rule == grammarAccess.getArithmeticOrRelationalExpressionRule()
						|| rule == grammarAccess.getUnaryOrArithmeticExpressionRule()
						|| rule == grammarAccess.getArithmeticOrShiftExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryOrMultiplicativeExpressionRule()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()) {
					sequence_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else break;
			case SysADLPackage.BLOCK_STATEMENT:
				sequence_BlockStatement(context, (BlockStatement) semanticObject); 
				return; 
			case SysADLPackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_BooleanLiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case SysADLPackage.CLASSIFICATION_EXPRESSION:
				sequence_ClassificationExpression(context, (ClassificationExpression) semanticObject); 
				return; 
			case SysADLPackage.COMPONENT_DEF:
				if (rule == grammarAccess.getNamedElementRule()
						|| rule == grammarAccess.getArchitectureDefRule()) {
					sequence_ArchitectureDef(context, (ComponentDef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementDefRule()
						|| rule == grammarAccess.getStructuralDefRule()
						|| rule == grammarAccess.getComponentDefRule()) {
					sequence_ComponentDef(context, (ComponentDef) semanticObject); 
					return; 
				}
				else break;
			case SysADLPackage.COMPONENT_USE:
				sequence_ComponentUse(context, (ComponentUse) semanticObject); 
				return; 
			case SysADLPackage.COMPOSITE_PORT_DEF:
				sequence_CompositePortDef(context, (CompositePortDef) semanticObject); 
				return; 
			case SysADLPackage.CONDITIONAL_LOGICAL_EXPRESSION:
				if (rule == grammarAccess.getInclusiveOrOrConditionalAndExpressionRule()
						|| rule == grammarAccess.getConditionalAndExpressionRule()) {
					sequence_ConditionalAndExpression(context, (ConditionalLogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getNonBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getNonNameExpressionRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getConditionalAndOrConditionalOrExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()) {
					sequence_ConditionalAndExpression_ConditionalOrExpression(context, (ConditionalLogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConditionalOrExpressionRule()) {
					sequence_ConditionalOrExpression(context, (ConditionalLogicalExpression) semanticObject); 
					return; 
				}
				else break;
			case SysADLPackage.CONDITIONAL_TEST_EXPRESSION:
				sequence_ConditionalTestExpression(context, (ConditionalTestExpression) semanticObject); 
				return; 
			case SysADLPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case SysADLPackage.CONNECTOR_BINDING:
				sequence_ConnectorBinding(context, (ConnectorBinding) semanticObject); 
				return; 
			case SysADLPackage.CONNECTOR_DEF:
				sequence_ConnectorDef(context, (ConnectorDef) semanticObject); 
				return; 
			case SysADLPackage.CONNECTOR_USE:
				sequence_ConnectorUse(context, (ConnectorUse) semanticObject); 
				return; 
			case SysADLPackage.CONSTRAINT_DEF:
				sequence_ConstraintDef(context, (ConstraintDef) semanticObject); 
				return; 
			case SysADLPackage.CONSTRAINT_USE:
				sequence_ConstraintUse(context, (ConstraintUse) semanticObject); 
				return; 
			case SysADLPackage.DATA_BUFFER:
				sequence_DataBuffer(context, (DataBuffer) semanticObject); 
				return; 
			case SysADLPackage.DATA_STORE:
				sequence_DataStore(context, (DataStore) semanticObject); 
				return; 
			case SysADLPackage.DATA_TYPE_DEF:
				sequence_DataTypeDef(context, (DataTypeDef) semanticObject); 
				return; 
			case SysADLPackage.DEFAULT_SWITCH_CLAUSE:
				sequence_DefaultSwitchClause(context, (DefaultSwitchClause) semanticObject); 
				return; 
			case SysADLPackage.DELEGATION:
				sequence_Delegation(context, (Delegation) semanticObject); 
				return; 
			case SysADLPackage.DIMENSION_DEF:
				sequence_DimensionDef(context, (DimensionDef) semanticObject); 
				return; 
			case SysADLPackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case SysADLPackage.ELSE_STATEMENT:
				sequence_ElseStatement(context, (ElseStatement) semanticObject); 
				return; 
			case SysADLPackage.ENUM_LITERAL_VALUE:
				sequence_EnumLiteralValue(context, (EnumLiteralValue) semanticObject); 
				return; 
			case SysADLPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case SysADLPackage.EXECUTABLE:
				sequence_Executable(context, (Executable) semanticObject); 
				return; 
			case SysADLPackage.EXECUTABLE_ALLOCATION:
				sequence_ExecutableAllocation(context, (ExecutableAllocation) semanticObject); 
				return; 
			case SysADLPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case SysADLPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case SysADLPackage.FOR_CONTROL:
				sequence_ForControl(context, (ForControl) semanticObject); 
				return; 
			case SysADLPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case SysADLPackage.IF_BLOCK_STATEMENT:
				sequence_IfBlockStatement(context, (IfBlockStatement) semanticObject); 
				return; 
			case SysADLPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case SysADLPackage.LOGICAL_EXPRESSION:
				if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getNonBlockStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getNonNameExpressionRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()
						|| rule == grammarAccess.getConditionalAndOrConditionalOrExpressionRule()
						|| rule == grammarAccess.getInclusiveOrOrConditionalAndExpressionRule()
						|| rule == grammarAccess.getExclusiveOrOrInclusiveOrExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndOrExclusiveOrExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityOrAndExpressionRule()) {
					sequence_AndExpression_EqualityExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()) {
					sequence_AndExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassificationOrEqualityExpressionRule()
						|| rule == grammarAccess.getEqualityExpressionRule()) {
					sequence_EqualityExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExclusiveOrExpressionRule()) {
					sequence_ExclusiveOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInclusiveOrExpressionRule()) {
					sequence_InclusiveOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else break;
			case SysADLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SysADLPackage.NAME_EXPRESSION:
				sequence_NameExpression(context, (NameExpression) semanticObject); 
				return; 
			case SysADLPackage.NATURAL_LITERAL_EXPRESSION:
				sequence_NaturalLiteralExpression(context, (NaturalLiteralExpression) semanticObject); 
				return; 
			case SysADLPackage.PACKAGE:
				sequence_Package(context, (sysADL_Sintax.Package) semanticObject); 
				return; 
			case SysADLPackage.PIN:
				sequence_Pin(context, (Pin) semanticObject); 
				return; 
			case SysADLPackage.PORT_USE:
				if (rule == grammarAccess.getNamedElementRule()
						|| rule == grammarAccess.getPortUseRule()) {
					sequence_PortUse(context, (PortUse) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPortUse_ReverseRule()) {
					sequence_PortUse_Reverse(context, (PortUse) semanticObject); 
					return; 
				}
				else break;
			case SysADLPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case SysADLPackage.PROPERTY_ACCESS_EXPRESSION:
				sequence_PropertyAccessExpression(context, (PropertyAccessExpression) semanticObject); 
				return; 
			case SysADLPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case SysADLPackage.PROTOCOL_BODY:
				sequence_ProtocolBody(context, (ProtocolBody) semanticObject); 
				return; 
			case SysADLPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case SysADLPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case SysADLPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case SysADLPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case SysADLPackage.SIMPLE_PORT_DEF:
				sequence_SimplePortDef(context, (SimplePortDef) semanticObject); 
				return; 
			case SysADLPackage.STRING_LITERAL_EXPRESSION:
				sequence_StringLiteralExpression(context, (StringLiteralExpression) semanticObject); 
				return; 
			case SysADLPackage.SWITCH_CLAUSE:
				sequence_SwitchClause(context, (SwitchClause) semanticObject); 
				return; 
			case SysADLPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case SysADLPackage.THIS_EXPRESSION:
				sequence_ThisExpression(context, (ThisExpression) semanticObject); 
				return; 
			case SysADLPackage.TYPE_USE:
				sequence_TypeUse_Impl(context, (TypeUse) semanticObject); 
				return; 
			case SysADLPackage.UNIT_DEF:
				sequence_UnitDef(context, (UnitDef) semanticObject); 
				return; 
			case SysADLPackage.VALUE_TYPE_DEF:
				sequence_ValueTypeDef(context, (ValueTypeDef) semanticObject); 
				return; 
			case SysADLPackage.VARIABLE_DECL:
				sequence_VariableDecl(context, (VariableDecl) semanticObject); 
				return; 
			case SysADLPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ElementDef returns ActionDef
	 *     NamedElement returns ActionDef
	 *     BehaviorDef returns ActionDef
	 *     ActionDef returns ActionDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inParameters+=Pin 
	 *         inParameters+=Pin* 
	 *         returnType=[TypeDef|QualifiedName] 
	 *         (constraints+=ConstraintUse | delegations+=ActivityDelegation | properties+=Property | behaDefs+=BehaviorDef | dataDefs+=DataDef)*
	 *     )
	 */
	protected void sequence_ActionDef(ISerializationContext context, ActionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProtocolBodyInternal returns ActionReceive
	 *     ActionReceive returns ActionReceive
	 *
	 * Constraint:
	 *     (var=TypeUse flowTo=[Pin|QualifiedName])
	 */
	protected void sequence_ActionReceive(ISerializationContext context, ActionReceive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTION_RECEIVE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTION_RECEIVE__VAR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTION_RECEIVE__FLOW_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTION_RECEIVE__FLOW_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionReceiveAccess().getVarTypeUseParserRuleCall_1_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getActionReceiveAccess().getFlowToPinQualifiedNameParserRuleCall_3_0_1(), semanticObject.getFlowTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProtocolBodyInternal returns ActionSend
	 *     ActionSend returns ActionSend
	 *
	 * Constraint:
	 *     (expr=Expression flowTo=[Pin|QualifiedName])
	 */
	protected void sequence_ActionSend(ISerializationContext context, ActionSend semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTION_SEND__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTION_SEND__EXPR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTION_SEND__FLOW_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTION_SEND__FLOW_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionSendAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getActionSendAccess().getFlowToPinQualifiedNameParserRuleCall_3_0_1(), semanticObject.getFlowTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ActionUse
	 *     ActivityFlowable returns ActionUse
	 *     ActionUse returns ActionUse
	 *
	 * Constraint:
	 *     (name=ID definition=[ActionDef|QualifiedName] pinIn+=Pin* properties+=Property*)
	 */
	protected void sequence_ActionUse(ISerializationContext context, ActionUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Allocation returns ActivityAllocation
	 *     ActivityAllocation returns ActivityAllocation
	 *
	 * Constraint:
	 *     (source=[ActivityDef|QualifiedName]? target=[StructuralDef|QualifiedName]?)
	 */
	protected void sequence_ActivityAllocation(ISerializationContext context, ActivityAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityBody returns ActivityBody
	 *
	 * Constraint:
	 *     (actions+=ActionUse* flows+=ActivityRelation* dataObjects+=DataObject*)
	 */
	protected void sequence_ActivityBody(ISerializationContext context, ActivityBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ActivityDef
	 *     NamedElement returns ActivityDef
	 *     BehaviorDef returns ActivityDef
	 *     ActivityDef returns ActivityDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inParameters+=Pin 
	 *         inParameters+=Pin* 
	 *         (outParameters+=Pin outParameters+=Pin*)? 
	 *         (properties+=Property | behaDefs+=BehaviorDef | dataDefs+=DataDef)* 
	 *         constraints+=ConstraintUse* 
	 *         delegations+=ActivityDelegation* 
	 *         acbody=ActivityBody?
	 *     )
	 */
	protected void sequence_ActivityDef(ISerializationContext context, ActivityDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityRelation returns ActivityDelegation
	 *     ActivityDelegation returns ActivityDelegation
	 *
	 * Constraint:
	 *     (source=[ActivityFlowable|QualifiedName] (target=[ActivityFlowable|QualifiedName] | targetSwitch=ActivitySwitch))
	 */
	protected void sequence_ActivityDelegation(ISerializationContext context, ActivityDelegation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityRelation returns ActivityFlow
	 *     ActivityFlow returns ActivityFlow
	 *
	 * Constraint:
	 *     (source=[ActivityFlowable|QualifiedName] (target=[ActivityFlowable|QualifiedName] | targetSwitch=ActivitySwitch)?)
	 */
	protected void sequence_ActivityFlow(ISerializationContext context, ActivityFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivitySwitchCase returns ActivitySwitchCase
	 *
	 * Constraint:
	 *     (condition=Expression target=[ActivityFlowable|QualifiedName])
	 */
	protected void sequence_ActivitySwitchCase(ISerializationContext context, ActivitySwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTIVITY_SWITCH_CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTIVITY_SWITCH_CASE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ACTIVITY_SWITCH_CASE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ACTIVITY_SWITCH_CASE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActivitySwitchCaseAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getActivitySwitchCaseAccess().getTargetActivityFlowableQualifiedNameParserRuleCall_4_0_1(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ActivityFlowable returns ActivitySwitch
	 *     ActivitySwitch returns ActivitySwitch
	 *
	 * Constraint:
	 *     (cases+=ActivitySwitchCase cases+=ActivitySwitchCase*)?
	 */
	protected void sequence_ActivitySwitch(ISerializationContext context, ActivitySwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (op1=UnaryOrMultiplicativeExpression (operator='+' | operator='-') op2=UnaryOrArithmeticExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArithmeticExpression
	 *     NonBlockStatement returns ArithmeticExpression
	 *     Expression returns ArithmeticExpression
	 *     PrimaryExpression returns ArithmeticExpression
	 *     NonNameExpression returns ArithmeticExpression
	 *     ParenthesizedExpression returns ArithmeticExpression
	 *     ConditionalAndOrConditionalOrExpression returns ArithmeticExpression
	 *     InclusiveOrOrConditionalAndExpression returns ArithmeticExpression
	 *     ExclusiveOrOrInclusiveOrExpression returns ArithmeticExpression
	 *     AndOrExclusiveOrExpression returns ArithmeticExpression
	 *     EqualityOrAndExpression returns ArithmeticExpression
	 *     ClassificationOrEqualityExpression returns ArithmeticExpression
	 *     RelationalOrClassificationExpression returns ArithmeticExpression
	 *     ArithmeticOrRelationalExpression returns ArithmeticExpression
	 *     UnaryOrArithmeticExpression returns ArithmeticExpression
	 *     ArithmeticOrShiftExpression returns ArithmeticExpression
	 *     ConditionalExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (op1=UnaryExpression (operator='*' | operator='/' | operator='%') op2=UnaryOrMultiplicativeExpression) | 
	 *         (op1=UnaryOrMultiplicativeExpression (operator='+' | operator='-') op2=UnaryOrArithmeticExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocationTable returns AllocationTable
	 *
	 * Constraint:
	 *     allocs+=Allocation*
	 */
	protected void sequence_AllocationTable(ISerializationContext context, AllocationTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LogicalExpression
	 *     NonBlockStatement returns LogicalExpression
	 *     Expression returns LogicalExpression
	 *     PrimaryExpression returns LogicalExpression
	 *     NonNameExpression returns LogicalExpression
	 *     ParenthesizedExpression returns LogicalExpression
	 *     ConditionalAndOrConditionalOrExpression returns LogicalExpression
	 *     InclusiveOrOrConditionalAndExpression returns LogicalExpression
	 *     ExclusiveOrOrInclusiveOrExpression returns LogicalExpression
	 *     ConditionalExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (op1=RelationalOrClassificationExpression (operator='=' | operator='!=') op2=ClassificationOrEqualityExpression) | 
	 *         (op1=ClassificationOrEqualityExpression operator='&' op2=EqualityOrAndExpression) | 
	 *         (op1=EqualityOrAndExpression operator='^' op2=AndOrExclusiveOrExpression) | 
	 *         (op1=AndOrExclusiveOrExpression operator='|' op2=ExclusiveOrOrInclusiveOrExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndOrExclusiveOrExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (op1=RelationalOrClassificationExpression (operator='=' | operator='!=') op2=ClassificationOrEqualityExpression) | 
	 *         (op1=ClassificationOrEqualityExpression operator='&' op2=EqualityOrAndExpression) | 
	 *         (op1=EqualityOrAndExpression operator='^' op2=AndOrExclusiveOrExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityOrAndExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (op1=RelationalOrClassificationExpression (operator='=' | operator='!=') op2=ClassificationOrEqualityExpression) | 
	 *         (op1=ClassificationOrEqualityExpression operator='&' op2=EqualityOrAndExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (op1=ClassificationOrEqualityExpression operator='&' op2=EqualityOrAndExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, LogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getOp1ClassificationOrEqualityExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOperatorAmpersandKeyword_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOp2EqualityOrAndExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ComponentDef
	 *     ArchitectureDef returns ComponentDef
	 *
	 * Constraint:
	 *     (name=ID ports+=PortUse* properties+=Property* composite=Configuration)
	 */
	protected void sequence_ArchitectureDef(ISerializationContext context, ComponentDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BlockStatement
	 *     BlockStatement returns BlockStatement
	 *
	 * Constraint:
	 *     body+=Statement*
	 */
	protected void sequence_BlockStatement(ISerializationContext context, BlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns BooleanLiteralExpression
	 *     NonNameExpression returns BooleanLiteralExpression
	 *     LiteralExpression returns BooleanLiteralExpression
	 *     BooleanLiteralExpression returns BooleanLiteralExpression
	 *
	 * Constraint:
	 *     isTrue?='true'
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, BooleanLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__IS_TRUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__IS_TRUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getIsTrueTrueKeyword_0(), semanticObject.isIsTrue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ClassificationExpression
	 *     NonBlockStatement returns ClassificationExpression
	 *     Expression returns ClassificationExpression
	 *     PrimaryExpression returns ClassificationExpression
	 *     NonNameExpression returns ClassificationExpression
	 *     ParenthesizedExpression returns ClassificationExpression
	 *     ConditionalAndOrConditionalOrExpression returns ClassificationExpression
	 *     InclusiveOrOrConditionalAndExpression returns ClassificationExpression
	 *     ExclusiveOrOrInclusiveOrExpression returns ClassificationExpression
	 *     AndOrExclusiveOrExpression returns ClassificationExpression
	 *     EqualityOrAndExpression returns ClassificationExpression
	 *     ClassificationOrEqualityExpression returns ClassificationExpression
	 *     RelationalOrClassificationExpression returns ClassificationExpression
	 *     ClassificationExpression returns ClassificationExpression
	 *     ConditionalExpression returns ClassificationExpression
	 *
	 * Constraint:
	 *     (op=ArithmeticOrRelationalExpression (operator='instanceof' | operator='hastype') typeName=[TypeDef|QualifiedName])
	 */
	protected void sequence_ClassificationExpression(ISerializationContext context, ClassificationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ComponentDef
	 *     StructuralDef returns ComponentDef
	 *     ComponentDef returns ComponentDef
	 *
	 * Constraint:
	 *     (isBoundary?='boundary'? name=ID ports+=PortUse* (properties+=Property | archDefs+=StructuralDef | dataDefs+=DataDef)* composite=Configuration?)
	 */
	protected void sequence_ComponentDef(ISerializationContext context, ComponentDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ComponentUse
	 *     ComponentUse returns ComponentUse
	 *
	 * Constraint:
	 *     (name=ID definition=[ComponentDef|QualifiedName] (lowerBound=EInt upperBound=EInt)? ports+=PortUse* properties+=Property*)
	 */
	protected void sequence_ComponentUse(ISerializationContext context, ComponentUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns CompositePortDef
	 *     NamedElement returns CompositePortDef
	 *     StructuralDef returns CompositePortDef
	 *     PortDef returns CompositePortDef
	 *     CompositePortDef returns CompositePortDef
	 *
	 * Constraint:
	 *     (name=ID ports+=PortUse* (properties+=Property | archDefs+=StructuralDef | dataDefs+=DataDef)*)
	 */
	protected void sequence_CompositePortDef(ISerializationContext context, CompositePortDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InclusiveOrOrConditionalAndExpression returns ConditionalLogicalExpression
	 *     ConditionalAndExpression returns ConditionalLogicalExpression
	 *
	 * Constraint:
	 *     (op1=ExclusiveOrOrInclusiveOrExpression operator='&&' op2=InclusiveOrOrConditionalAndExpression)
	 */
	protected void sequence_ConditionalAndExpression(ISerializationContext context, ConditionalLogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalAndExpressionAccess().getOp1ExclusiveOrOrInclusiveOrExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getConditionalAndExpressionAccess().getOperatorAmpersandAmpersandKeyword_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionalAndExpressionAccess().getOp2InclusiveOrOrConditionalAndExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionalLogicalExpression
	 *     NonBlockStatement returns ConditionalLogicalExpression
	 *     Expression returns ConditionalLogicalExpression
	 *     PrimaryExpression returns ConditionalLogicalExpression
	 *     NonNameExpression returns ConditionalLogicalExpression
	 *     ParenthesizedExpression returns ConditionalLogicalExpression
	 *     ConditionalAndOrConditionalOrExpression returns ConditionalLogicalExpression
	 *     ConditionalExpression returns ConditionalLogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (op1=ExclusiveOrOrInclusiveOrExpression operator='&&' op2=InclusiveOrOrConditionalAndExpression) | 
	 *         (op1=InclusiveOrOrConditionalAndExpression operator='||' op2=ConditionalAndOrConditionalOrExpression)
	 *     )
	 */
	protected void sequence_ConditionalAndExpression_ConditionalOrExpression(ISerializationContext context, ConditionalLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalOrExpression returns ConditionalLogicalExpression
	 *
	 * Constraint:
	 *     (op1=InclusiveOrOrConditionalAndExpression operator='||' op2=ConditionalAndOrConditionalOrExpression)
	 */
	protected void sequence_ConditionalOrExpression(ISerializationContext context, ConditionalLogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalOrExpressionAccess().getOp1InclusiveOrOrConditionalAndExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getConditionalOrExpressionAccess().getOperatorVerticalLineVerticalLineKeyword_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConditionalOrExpressionAccess().getOp2ConditionalAndOrConditionalOrExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionalTestExpression
	 *     NonBlockStatement returns ConditionalTestExpression
	 *     Expression returns ConditionalTestExpression
	 *     PrimaryExpression returns ConditionalTestExpression
	 *     NonNameExpression returns ConditionalTestExpression
	 *     ParenthesizedExpression returns ConditionalTestExpression
	 *     ConditionalExpression returns ConditionalTestExpression
	 *     ConditionalTestExpression returns ConditionalTestExpression
	 *
	 * Constraint:
	 *     (op1=ConditionalAndOrConditionalOrExpression op2=Expression op3=ConditionalExpression)
	 */
	protected void sequence_ConditionalTestExpression(ISerializationContext context, ConditionalTestExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP2));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.CONDITIONAL_TEST_EXPRESSION__OP3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalTestExpressionAccess().getOp1ConditionalAndOrConditionalOrExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getConditionalTestExpressionAccess().getOp2ExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.accept(grammarAccess.getConditionalTestExpressionAccess().getOp3ConditionalExpressionParserRuleCall_4_0(), semanticObject.getOp3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (components+=ComponentUse* connectors+=ConnectorUse* delegations+=Delegation*)
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorBinding returns ConnectorBinding
	 *
	 * Constraint:
	 *     (firstPort=[PortUse|QualifiedName] secondPort=[PortUse|QualifiedName])
	 */
	protected void sequence_ConnectorBinding(ISerializationContext context, ConnectorBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.CONNECTOR_BINDING__FIRST_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.CONNECTOR_BINDING__FIRST_PORT));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.CONNECTOR_BINDING__SECOND_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.CONNECTOR_BINDING__SECOND_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectorBindingAccess().getFirstPortPortUseQualifiedNameParserRuleCall_0_0_1(), semanticObject.getFirstPort());
		feeder.accept(grammarAccess.getConnectorBindingAccess().getSecondPortPortUseQualifiedNameParserRuleCall_2_0_1(), semanticObject.getSecondPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ConnectorDef
	 *     NamedElement returns ConnectorDef
	 *     StructuralDef returns ConnectorDef
	 *     ConnectorDef returns ConnectorDef
	 *
	 * Constraint:
	 *     (name=ID ports+=PortUse_Reverse* composite=Configuration? flows+=Flow* (properties+=Property | archDefs+=StructuralDef | dataDefs+=DataDef)*)
	 */
	protected void sequence_ConnectorDef(ISerializationContext context, ConnectorDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ConnectorUse
	 *     ConnectorUse returns ConnectorUse
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         definition=[ConnectorDef|QualifiedName] 
	 *         (lowerBound=EInt upperBound=EInt)? 
	 *         (bindings+=ConnectorBinding bindings+=ConnectorBinding*)? 
	 *         ports+=PortUse_Reverse* 
	 *         properties+=Property*
	 *     )
	 */
	protected void sequence_ConnectorUse(ISerializationContext context, ConnectorUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ConstraintDef
	 *     NamedElement returns ConstraintDef
	 *     BehaviorDef returns ConstraintDef
	 *     ConstraintDef returns ConstraintDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inParameters+=Pin 
	 *         inParameters+=Pin* 
	 *         (outParameters+=Pin outParameters+=Pin*)? 
	 *         equation=Expression? 
	 *         properties+=Property*
	 *     )
	 */
	protected void sequence_ConstraintDef(ISerializationContext context, ConstraintDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintUse returns ConstraintUse
	 *
	 * Constraint:
	 *     (kind=ConstraintKind definition=[ConstraintDef|QualifiedName] (params+=[TypeUse|QualifiedName] params+=[TypeUse|QualifiedName]*)?)
	 */
	protected void sequence_ConstraintUse(ISerializationContext context, ConstraintUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns DataBuffer
	 *     ActivityFlowable returns DataBuffer
	 *     DataObject returns DataBuffer
	 *     DataBuffer returns DataBuffer
	 *
	 * Constraint:
	 *     (name=ID type=[TypeDef|QualifiedName] (properties+=Property properties+=Property*)? initValue=Expression?)
	 */
	protected void sequence_DataBuffer(ISerializationContext context, DataBuffer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns DataStore
	 *     ActivityFlowable returns DataStore
	 *     DataObject returns DataStore
	 *     DataStore returns DataStore
	 *
	 * Constraint:
	 *     (name=ID type=[TypeDef|QualifiedName] properties+=Property* initValue=Expression?)
	 */
	protected void sequence_DataStore(ISerializationContext context, DataStore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns DataTypeDef
	 *     TypeDef returns DataTypeDef
	 *     NamedElement returns DataTypeDef
	 *     DataDef returns DataTypeDef
	 *     DataTypeDef returns DataTypeDef
	 *
	 * Constraint:
	 *     (name=ID superType=[DataTypeDef|QualifiedName]? dataTypeAttributes+=TypeUse* properties+=Property*)
	 */
	protected void sequence_DataTypeDef(ISerializationContext context, DataTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefaultSwitchClause returns DefaultSwitchClause
	 *
	 * Constraint:
	 *     body=Statement
	 */
	protected void sequence_DefaultSwitchClause(ISerializationContext context, DefaultSwitchClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultSwitchClauseAccess().getBodyStatementParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Delegation returns Delegation
	 *
	 * Constraint:
	 *     (fullPort=[PortUse|QualifiedName] portProxy=[PortUse|QualifiedName])
	 */
	protected void sequence_Delegation(ISerializationContext context, Delegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.DELEGATION__FULL_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.DELEGATION__FULL_PORT));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.DELEGATION__PORT_PROXY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.DELEGATION__PORT_PROXY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelegationAccess().getFullPortPortUseQualifiedNameParserRuleCall_0_0_1(), semanticObject.getFullPort());
		feeder.accept(grammarAccess.getDelegationAccess().getPortProxyPortUseQualifiedNameParserRuleCall_2_0_1(), semanticObject.getPortProxy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns DimensionDef
	 *     NamedElement returns DimensionDef
	 *     DataDef returns DimensionDef
	 *     DimensionDef returns DimensionDef
	 *
	 * Constraint:
	 *     (name=ID (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_DimensionDef(ISerializationContext context, DimensionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DoStatement
	 *     NonBlockStatement returns DoStatement
	 *     DoStatement returns DoStatement
	 *
	 * Constraint:
	 *     (body=Statement condition=Expression)
	 */
	protected void sequence_DoStatement(ISerializationContext context, DoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__BODY));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoStatementAccess().getBodyStatementParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoStatementAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElseStatement returns ElseStatement
	 *
	 * Constraint:
	 *     body=Statement
	 */
	protected void sequence_ElseStatement(ISerializationContext context, ElseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ELSE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ELSE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseStatementAccess().getBodyStatementParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumLiteralValue returns EnumLiteralValue
	 *
	 * Constraint:
	 *     key=EString
	 */
	protected void sequence_EnumLiteralValue(ISerializationContext context, EnumLiteralValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.ENUM_LITERAL_VALUE__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.ENUM_LITERAL_VALUE__KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralValueAccess().getKeyEStringParserRuleCall_0(), semanticObject.getKey());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns Enumeration
	 *     TypeDef returns Enumeration
	 *     NamedElement returns Enumeration
	 *     DataDef returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID properties+=Property* literals+=EnumLiteralValue literals+=EnumLiteralValue*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassificationOrEqualityExpression returns LogicalExpression
	 *     EqualityExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (op1=RelationalOrClassificationExpression (operator='=' | operator='!=') op2=ClassificationOrEqualityExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExclusiveOrExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (op1=EqualityOrAndExpression operator='^' op2=AndOrExclusiveOrExpression)
	 */
	protected void sequence_ExclusiveOrExpression(ISerializationContext context, LogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusiveOrExpressionAccess().getOp1EqualityOrAndExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getExclusiveOrExpressionAccess().getOperatorCircumflexAccentKeyword_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExclusiveOrExpressionAccess().getOp2AndOrExclusiveOrExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Allocation returns ExecutableAllocation
	 *     ExecutableAllocation returns ExecutableAllocation
	 *
	 * Constraint:
	 *     (source=[Executable|QualifiedName]? target=[ActionDef|QualifiedName]?)
	 */
	protected void sequence_ExecutableAllocation(ISerializationContext context, ExecutableAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns Executable
	 *     NamedElement returns Executable
	 *     Executable returns Executable
	 *
	 * Constraint:
	 *     (name=ID (params+=TypeUse params+=TypeUse*)? returnType=[TypeDef|QualifiedName] body+=NonBlockStatement*)
	 */
	protected void sequence_Executable(ISerializationContext context, Executable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Expression
	 *     NonBlockStatement returns Expression
	 *     Expression returns Expression
	 *     PrimaryExpression returns Expression
	 *     NonNameExpression returns Expression
	 *     ParenthesizedExpression returns Expression
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getValueEStringParserRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Flow returns Flow
	 *
	 * Constraint:
	 *     (flowType=[TypeDef|QualifiedName] source=[PortUse|QualifiedName] destination=[PortUse|QualifiedName])
	 */
	protected void sequence_Flow(ISerializationContext context, Flow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.FLOW__FLOW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.FLOW__FLOW_TYPE));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.FLOW__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.FLOW__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.FLOW__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.FLOW__DESTINATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlowAccess().getFlowTypeTypeDefQualifiedNameParserRuleCall_0_0_1(), semanticObject.getFlowType());
		feeder.accept(grammarAccess.getFlowAccess().getSourcePortUseQualifiedNameParserRuleCall_2_0_1(), semanticObject.getSource());
		feeder.accept(grammarAccess.getFlowAccess().getDestinationPortUseQualifiedNameParserRuleCall_4_0_1(), semanticObject.getDestination());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForControl returns ForControl
	 *
	 * Constraint:
	 *     (vars+=ForVar vars+=ForVar)
	 */
	protected void sequence_ForControl(ISerializationContext context, ForControl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     NonBlockStatement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (control=ForControl body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.FOR_STATEMENT__CONTROL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.FOR_STATEMENT__CONTROL));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.FOR_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.FOR_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getControlForControlParserRuleCall_2_0(), semanticObject.getControl());
		feeder.accept(grammarAccess.getForStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfBlockStatement returns IfBlockStatement
	 *
	 * Constraint:
	 *     (main_if=IfStatement paralel_ifs+=IfStatement* sequential_ifs+=IfStatement* else=ElseStatement?)
	 */
	protected void sequence_IfBlockStatement(ISerializationContext context, IfBlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.IF_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.IF_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.IF_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.IF_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InclusiveOrExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (op1=AndOrExclusiveOrExpression operator='|' op2=ExclusiveOrOrInclusiveOrExpression)
	 */
	protected void sequence_InclusiveOrExpression(ISerializationContext context, LogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP1));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.BINARY_EXPRESSION__OP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusiveOrExpressionAccess().getOp1AndOrExclusiveOrExpressionParserRuleCall_0_0(), semanticObject.getOp1());
		feeder.accept(grammarAccess.getInclusiveOrExpressionAccess().getOperatorVerticalLineKeyword_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getInclusiveOrExpressionAccess().getOp2ExclusiveOrOrInclusiveOrExpressionParserRuleCall_2_0(), semanticObject.getOp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *     NamedElement returns Model
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         involvedElements+=[ElementDef|QualifiedName]* 
	 *         (properties+=Property | packages+=Package | requirements+=Requirement)* 
	 *         allocation=AllocationTable?
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryOrMultiplicativeExpression returns ArithmeticExpression
	 *     MultiplicativeExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (op1=UnaryExpression (operator='*' | operator='/' | operator='%') op2=UnaryOrMultiplicativeExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns NameExpression
	 *     NameExpression returns NameExpression
	 *
	 * Constraint:
	 *     cite=[NamedElement|QualifiedName]
	 */
	protected void sequence_NameExpression(ISerializationContext context, NameExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.NAME_EXPRESSION__CITE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.NAME_EXPRESSION__CITE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameExpressionAccess().getCiteNamedElementQualifiedNameParserRuleCall_0_1(), semanticObject.getCite());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns NaturalLiteralExpression
	 *     NonNameExpression returns NaturalLiteralExpression
	 *     LiteralExpression returns NaturalLiteralExpression
	 *     NaturalLiteralExpression returns NaturalLiteralExpression
	 *
	 * Constraint:
	 *     int_value=INT
	 */
	protected void sequence_NaturalLiteralExpression(ISerializationContext context, NaturalLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.NATURAL_LITERAL_EXPRESSION__INT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.NATURAL_LITERAL_EXPRESSION__INT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalLiteralExpressionAccess().getInt_valueINTTerminalRuleCall_0(), semanticObject.getInt_value());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         imports+=[Package|QualifiedName]* 
	 *         elementImports+=[ElementDef|QualifiedName]* 
	 *         (properties+=Property | architectures+=ElementDef | architectures+=ArchitectureDef)*
	 *     )
	 */
	protected void sequence_Package(ISerializationContext context, sysADL_Sintax.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns Pin
	 *
	 * Constraint:
	 *     (name=ID isFlow?='flow'? definition=[TypeDef|QualifiedName])
	 */
	protected void sequence_Pin(ISerializationContext context, Pin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns PortUse
	 *     PortUse returns PortUse
	 *
	 * Constraint:
	 *     (name=ID definition=[PortDef|QualifiedName] (lowerBound=EInt upperBound=EInt)? properties+=Property*)
	 */
	protected void sequence_PortUse(ISerializationContext context, PortUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortUse_Reverse returns PortUse
	 *
	 * Constraint:
	 *     (name=ID definition=[PortDef|QualifiedName] (lowerBound=EInt upperBound=EInt)? properties+=Property*)
	 */
	protected void sequence_PortUse_Reverse(ISerializationContext context, PortUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyAccessExpression returns PropertyAccessExpression
	 *
	 * Constraint:
	 *     ((target=NonNameExpression | target=NameExpression) field=[NamedElement|QualifiedName])
	 */
	protected void sequence_PropertyAccessExpression(ISerializationContext context, PropertyAccessExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=ID type=[TypeDef|QualifiedName]? value=Expression?)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProtocolBody returns ProtocolBody
	 *     ProtocolBodyInternal returns ProtocolBody
	 *
	 * Constraint:
	 *     (recControl=ProtocolControl body=ProtocolBodyInternal (recType=ProtocolAlternativeType recursive=ProtocolBody)?)
	 */
	protected void sequence_ProtocolBody(ISerializationContext context, ProtocolBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns Protocol
	 *     NamedElement returns Protocol
	 *     BehaviorDef returns Protocol
	 *     Protocol returns Protocol
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inParameters+=Pin 
	 *         inParameters+=Pin* 
	 *         (outParameters+=Pin outParameters+=Pin*)? 
	 *         (properties+=Property behaDefs+=BehaviorDef dataDefs+=DataDef)* 
	 *         delegations+=ActivityDelegation* 
	 *         body=ProtocolBody
	 *     )
	 */
	protected void sequence_Protocol(ISerializationContext context, Protocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RelationalExpression
	 *     NonBlockStatement returns RelationalExpression
	 *     Expression returns RelationalExpression
	 *     PrimaryExpression returns RelationalExpression
	 *     NonNameExpression returns RelationalExpression
	 *     ParenthesizedExpression returns RelationalExpression
	 *     ConditionalAndOrConditionalOrExpression returns RelationalExpression
	 *     InclusiveOrOrConditionalAndExpression returns RelationalExpression
	 *     ExclusiveOrOrInclusiveOrExpression returns RelationalExpression
	 *     AndOrExclusiveOrExpression returns RelationalExpression
	 *     EqualityOrAndExpression returns RelationalExpression
	 *     ClassificationOrEqualityExpression returns RelationalExpression
	 *     RelationalOrClassificationExpression returns RelationalExpression
	 *     ArithmeticOrRelationalExpression returns RelationalExpression
	 *     RelationalExpression returns RelationalExpression
	 *     ConditionalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (op1=ArithmeticOrShiftExpression (operator='<' | operator='>' | operator='<=' | operator='>=') op2=ArithmeticOrShiftExpression)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Requirement
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         id=EFloat 
	 *         text=EString? 
	 *         (satisfiedBy+=[ElementDef|QualifiedName] satisfiedBy+=[ElementDef|QualifiedName]*)? 
	 *         (derivedBy+=[Requirement|QualifiedName] derivedBy+=[Requirement|QualifiedName]*)? 
	 *         (properties+=Property | composition+=Requirement)*
	 *     )
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     NonBlockStatement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.RETURN_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.RETURN_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticOrShiftExpression returns ShiftExpression
	 *     ShiftExpression returns ShiftExpression
	 *
	 * Constraint:
	 *     (op1=UnaryOrArithmeticExpression (operator='<<' | operator='>>' | operator='>>>') op2=ArithmeticOrShiftExpression)
	 */
	protected void sequence_ShiftExpression(ISerializationContext context, ShiftExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns SimplePortDef
	 *     NamedElement returns SimplePortDef
	 *     StructuralDef returns SimplePortDef
	 *     PortDef returns SimplePortDef
	 *     SimplePortDef returns SimplePortDef
	 *
	 * Constraint:
	 *     (name=ID flowProperties=FlowProperty flowType=[TypeDef|QualifiedName] (properties+=Property | archDefs+=StructuralDef | dataDefs+=DataDef)*)
	 */
	protected void sequence_SimplePortDef(ISerializationContext context, SimplePortDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns StringLiteralExpression
	 *     NonNameExpression returns StringLiteralExpression
	 *     LiteralExpression returns StringLiteralExpression
	 *     StringLiteralExpression returns StringLiteralExpression
	 *
	 * Constraint:
	 *     str_value=STRING
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, StringLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.STRING_LITERAL_EXPRESSION__STR_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.STRING_LITERAL_EXPRESSION__STR_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getStr_valueSTRINGTerminalRuleCall_0(), semanticObject.getStr_value());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchClause returns SwitchClause
	 *
	 * Constraint:
	 *     (value=Expression body=Statement)
	 */
	protected void sequence_SwitchClause(ISerializationContext context, SwitchClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__VALUE));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.SWITCH_CLAUSE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchClauseAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getSwitchClauseAccess().getBodyStatementParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (expr=Expression clauses+=SwitchClause* clauses+=DefaultSwitchClause)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns ThisExpression
	 *     NonNameExpression returns ThisExpression
	 *     ThisExpression returns ThisExpression
	 *
	 * Constraint:
	 *     {ThisExpression}
	 */
	protected void sequence_ThisExpression(ISerializationContext context, ThisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeUse returns TypeUse
	 *     NamedElement returns TypeUse
	 *     TypeUse_Impl returns TypeUse
	 *
	 * Constraint:
	 *     (name=ID definition=[TypeDef|QualifiedName] properties+=Property*)
	 */
	protected void sequence_TypeUse_Impl(ISerializationContext context, TypeUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns UnitDef
	 *     NamedElement returns UnitDef
	 *     DataDef returns UnitDef
	 *     UnitDef returns UnitDef
	 *
	 * Constraint:
	 *     (name=ID dimension=[DimensionDef|QualifiedName]? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_UnitDef(ISerializationContext context, UnitDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ValueTypeDef
	 *     TypeDef returns ValueTypeDef
	 *     NamedElement returns ValueTypeDef
	 *     DataDef returns ValueTypeDef
	 *     ValueTypeDef returns ValueTypeDef
	 *
	 * Constraint:
	 *     (name=ID superType=[ValueTypeDef|QualifiedName]? unit=[UnitDef|QualifiedName]? dimension=[DimensionDef|QualifiedName]? properties+=Property*)
	 */
	protected void sequence_ValueTypeDef(ISerializationContext context, ValueTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableDecl
	 *     NonBlockStatement returns VariableDecl
	 *     VariableDecl returns VariableDecl
	 *
	 * Constraint:
	 *     (name=ID definition=[TypeDef|QualifiedName] value=Expression)
	 */
	protected void sequence_VariableDecl(ISerializationContext context, VariableDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.TYPE_USE__DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.TYPE_USE__DEFINITION));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.VARIABLE_DECL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.VARIABLE_DECL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclAccess().getDefinitionTypeDefQualifiedNameParserRuleCall_3_0_1(), semanticObject.getDefinition());
		feeder.accept(grammarAccess.getVariableDeclAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     NonBlockStatement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysADLPackage.Literals.LOOP_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
